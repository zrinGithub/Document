### 动态规划

参考文章：

https://www.zhihu.com/question/23995189



#### 简单的例子-斐波拉契数列

首先用斐波拉契数列来说明：

我们可以使用自顶向下的做法，对每一个计算过的数做备忘（就像深度优先一样），也可以自底向上来计算（这样我们就只用存储两个中间状态值）：

```java
public int f(int n){
    int f1 = 1;
    int f2 = 1;
    if(n<2) return 1;
    for(int i = 2; i <= n; i++){
        f2 = f1 + f2;
        f1 = f2 - f1;
    }
    return f2;
}
```



#### 算零钱

如果我们现在有1、5、11三种面值的钞票，现在如何凑成15的面值？

如果是贪心算法，我们直接拿最大范围面值来凑，也就是11+4*1共5张，

如果我们加上限制，要求数量最小，这个时候就需要使用动态规划，也就是：
$$
f(n) = min\{ f(n-1),f(n-5),f(n-11) \} + 1
$$
描述为文字就是：

*1、5、11我们选择任意一张之后，计算每种情况下凑剩余金额的最小值*



这样一来，很多问题都简单化了，比如我们现在要凑够任意金额的面值，只需要找到更小的f()值即可。

```java
    public int solution(int n) {
        int[] f = new int[n + 1];
        f[0] = 0;
        for (int i = 1; i <= n; i++) {
            int cost = Integer.MAX_VALUE;
            if (i >= 1) cost = Math.min(cost, f[i - 1] + 1);
            if (i >= 5) cost = Math.min(cost, f[i - 5] + 1);
            if (i >= 11) cost = Math.min(cost, f[i - 11] + 1);
            f[i] = cost;
        }
        return f[n];
    }
```



#### 小朋友过河

之前算零钱可以看出来，有时候贪心算法解决不了问题，或者得不到最优解，同样的我们可以再看一个例子：

如果有n个小朋友晚上过河，桥最大承载两人，只有一个手电筒（每次两人过河需要一个人把手电筒拿回来），每个小朋友过河的时间对应数组t[n+1]，问最短全部过河的时间。



首先看需要过河的次数：把两人过河一人回来看做一轮那么需要N-1轮，次数2(n-1)=2n-2,且最后一次没人回来因此次数就是2n-3

如果使用贪心算法，那么直接让跑最快的小朋友每次都回来还手电筒，但是这样做会导致每次最快的都需要陪同再过一次桥，每一轮可能消耗的时间比两个耗时长的一起过河会更多。



我们dp设定为最短消耗时间，我们先把小朋友排序，即t[n+1]数组递增（t[0]=0特殊情况），考虑基础情况：

dp[1] = t[1]

dp[2] = t[2]

dp[3] = t[2] + t[1] + t[3] 因为只有三个人，所以只有一种情况

dp[4] = 第一次肯定是最快的两个的人过河，之后剩两个人需要考虑是由最快的一直送（每次陪同回来）也就是dp[3]+t[1]+t[4]。还是说第一次最快的送，然后两个慢的一起走，最后再由第二快的把手电筒送过去一起回来：dp[2]+t[1]+t[4]+t[2]+t[2]

代码：

```java
class Solution {
    public int ship(int[] t) {
        if (t == null) return 0;
        int n = t.length;
        if (n == 1) return t[0];
        if (n == 2) return t[1];

        int[] dp = new int[n + 1];
        //初始化线性模型为-1
        for (int i = 0; i <= n; i++) {
            dp[i] = -1;
        }
        dp[0] = 0;
        dp[1] = t[0];
        dp[2] = t[1];
        for (int i = 3; i <= n; i++) {
            dp[n] = Math.min(dp[n - 1] + t[0] + t[i - 1], dp[n - 2] + t[0] + t[i - 1] + 2 * t[1]);
        }
        return dp[n];
    }
}
```







#### 钢材切割

给定长度为i的钢材和 p 的价格表

p[i]表示钢材长度i对应的价格



如：

i=4

p = [0, 1 , 5 , 8, 9 ] 

价格最大收益为切成两段长度为2的钢材，收益为p[2]+p[2]=10



首先看递归的做法：把问题简化为左边已经固定长度，寻找切除右边，然后比较情况得到最优解
$$
r(n)=max(p[i]+r(n-i))   1<=i<=n
$$

```java
public int cut(int[] p, int n){
    if(n==0) return 0;
    int res = p[n];
    for(int i=1;i<=n;i++){
        res = Math.max(res, p[i]+cut(p,n-i));
    }
    return res;
}
```

这里也可以使用数组来做备忘，不然会有很多重复计算。

重要的是，递归回溯是自顶向下的，每次树的分支向下需要遍历所有的情况（也可以剪枝或者做备忘），



但是动态规划是从小问题到大问题，自底向上的来解决的，所以能够处理备忘的情况

```java
public int cut(int[] p,int n){
    int r[] = new int[n+1];
    r[0] = 0;
    for(int i=1;i<=n;i++){
        int res = 0;
        for(int j=1;j<=i;j++){
            res = Math.max(res,p[j]+r[i-j]);
        }
        r[i] = res;
    }
    return r[n];
}
```



#### 







#### 有向无环图的最短路径

按照拓扑顺序松弛顶点，实际上和动态规划的思路一致，就是在拓扑顺序的每个节点找到当前最优解。



