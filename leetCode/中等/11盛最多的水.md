来源：[力扣中国](https://leetcode-cn.com/)

#### [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

难度中等

给你 *n* 个非负整数 *a*1，*a*2，...，*a*n，每个数代表坐标中的一个点 (*i*, *ai*) 。在坐标内画 *n* 条垂直线，垂直线 *i* 的两个端点分别为 (*i*, *ai*) 和 (*i*, 0)。找出其中的两条线，使得它们与 *x* 轴共同构成的容器可以容纳最多的水。

**说明：**你不能倾斜容器，且 *n* 的值至少为 2。

 

![img](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)

图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。

 

**示例：**

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49
```



**答案：**

我们使用两个指针指向两端，每次把最小的一个边作为高来计算面积

之后我们移动最小的边所在的指针向内移动。



为什么移动最小边的指针？

我们每次计算面积都是最小边*宽度来计算的，也就是当前宽度是接下来（指针向内移动）最大的情况下，这已经是最小边所能得到的最大面积，之后如果移动的是最大边所在的指针，那么无非两种情况：

1. 之后的边比当前最小边大，但是我们还是用最小边做高，所以面积随着宽度变小
2. 之后的边比最小边小，那么不仅宽度变小，高也变小了

不管哪种情况，我们移动最大边只会让面积变小。

```java
class Solution {
    public int maxArea(int[] height) {
        if (height == null || height.length < 2) return 0;

        int result = 0;//面积
        int left = 0;
        int right = height.length - 1;
        while (left < right) {
            if (height[left] < height[right]) {
                result = Math.max(result, height[left] * (right - left));
                left++;
            } else {
                result = Math.max(result, height[right] * (right - left));
                right--;
            }
        }
        return result;
    }
}
```



