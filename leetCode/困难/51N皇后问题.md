来源：[力扣中国](https://leetcode-cn.com/)

#### [51. N皇后](https://leetcode-cn.com/problems/n-queens/)

难度困难

*n* 皇后问题研究的是如何将 *n* 个皇后放置在 *n*×*n* 的棋盘上，并且使皇后彼此之间不能相互攻击。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/8-queens.png)

上图为 8 皇后问题的一种解法。

给定一个整数 *n*，返回所有不同的 *n* 皇后问题的解决方案。

每一种解法包含一个明确的 *n* 皇后问题的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。

**示例:**

```
输入: 4
输出: [
 [".Q..",  // 解法 1
  "...Q",
  "Q...",
  "..Q."],

 ["..Q.",  // 解法 2
  "Q...",
  "...Q",
  ".Q.."]
]
解释: 4 皇后问题存在两个不同的解法。
```

 

**提示：**

- **皇后**，是[国际象棋](https://baike.baidu.com/item/国际象棋)中的棋子，意味着[国王](https://baike.baidu.com/item/国王)的妻子。皇后只做一件事，那就是“[吃子](https://baike.baidu.com/item/吃子)”。当她遇见可以吃的棋子时，就迅速冲上去吃掉棋子。当然，她横、竖、斜都可走一到七步，可进可退。（引用自 [百度百科 - 皇后](https://baike.baidu.com/item/皇后/15860305?fr=aladdin) ）



**答案：**

标准的回溯问题，沿着决策树筛选所有结果：

```java
class Solution {
    List<List<String>> result = new ArrayList<>();

    //使用回溯剪枝穷举所有的可能性
    public List<List<String>> solveNQueens(int n) {
        LinkedList<String> board = new LinkedList<>();
        initBoard(board, n);
        //从第0行开始
        backtrack(board, 0);
        return result;
    }

    //初始化棋盘
    private void initBoard(List<String> board, int n) {
        StringBuilder temp = new StringBuilder();
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                temp.append(".");
            }
            board.add(temp.toString());
            temp.delete(0, temp.length());
        }
    }

    /**
     * @param track 轨迹
     * @param row   选择的行
     */
    private void backtrack(LinkedList<String> track, int row) {
        int n = track.size();
        //结束条件，行数==棋盘大小
        if (row == n) {
            //注意这里一定要用拷贝，不然引用随着撤销选择就修改了
            result.add(new ArrayList<>(track));
        }

        //在第row行找到对应的列
        //检验棋盘，看当前位置是否合适
        for (int col = 0; col < n; col++) {
            if (isValid(row, col, track)) {
                //满足条件，加入选择
                String oldStr = track.get(row);
                String newStr = oldStr.substring(0, col) + 'Q' + oldStr.substring(col + 1, oldStr.length());
                track.set(row, newStr);
                //回溯
                backtrack(track, row + 1);
                //撤销选择
                //这里感觉应该用二维数组，处理起来简单一点
                track.set(row, oldStr);
            }
        }
    }

    //检验对应位置是否满足条件
    private boolean isValid(int row, int col, LinkedList<String> board) {
        int n = board.size();
        //col列是否有对应元素
        for (int i = 0; i < n; i++) {
            if (board.get(i).charAt(col) == 'Q')
                return false;
        }
        //因为当前行下面的行还没开始放置，所以只需要检测左上和右上

        //检查左上
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
            if (board.get(i).charAt(j) == 'Q') return false;
        }

        //检查右上
        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
            if (board.get(i).charAt(j) == 'Q') return false;
        }

        return true;
    }
}
```

