# 算法笔记

该文档为[算法（第四版）](https://www.ituring.com.cn/book/875)笔记

参考

- [数据结构与算法](https://www.cnblogs.com/skywang12345/p/3603935.html)
- [Markdown数学公式语法](https://www.jianshu.com/p/e74eb43960a1)



下载jar包[algs4.jar](https://algs4.cs.princeton.edu/code/)



## 目录

[TOC]



## 一.基础

### 矩阵乘法

[维基百科](http://zh.wikipedia.org/wiki/矩陣乘法)

矩阵A*B，要求矩阵A的列数和B的行数相同，可以使用向量的方式计算

```java
    public static double[][] matrixMultiplication(double[][] a, double[][] b) {
        int row = a.length;
        int col = b[0].length;
        int inner = b.length;
        double[][] result = new double[row][col];
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                for (int k = 0; k < inner; k++) {
                    result[i][j] += a[i][k] * b[k][j];
                }
            }
        }
        return result;
    }
```



### 牛顿平方根

函数f(x)=x^2-N，计算N的平方根也就是求f(x)=0的x值

倒数为2x，在n点做切线函数为g(x)=2x(x-n)+(n^2-N)  切线与x轴的交点为：

x=(n+N/n)/2

逐渐靠近计算

```java
    public static double sqrt(double c) {
        //误差范围
        double err = 1e-10;
        double t = c;
        while (Math.abs(t - c / t) > err * t)
            t = (c / t + t) / 2.0;
        return t;
    }
```



### Bag&Queue&Stack

#### Bag

- 使用链表实现

- 不支持从中删除元素的集合类型
- 像一个背包一样，遍历的时候不需要考虑元素的处理顺序

适合用于做与元素顺序无关的统计：

```java
public class BagTest {
    public static void main(String[] args) {
        Bag<Double> numbers = new Bag<Double>();
        while (!StdIn.isEmpty())
            numbers.add(StdIn.readDouble());
        int N = numbers.size();
        double sum = 0.0;
        for (double x : numbers)
            sum += x;
        //计算平均值
        double mean = sum / N;
        sum = 0.0;
        //计算每个值和平均值之差的平方和除以(N-1)后的平方根
        //这里为什么除以N-1而不是N 参考https://www.zhihu.com/question/20099757
        for (double x : numbers)
            sum += (x - mean) * (x - mean);
        double std = Math.sqrt(sum / (N - 1));
        StdOut.printf("Mean: %.2f\n", mean);
        StdOut.printf("Std dev: %.2f\n", std);
    }
}
```





#### Queue

- FIFO

可以使用单向链表来实现队列，但是只能在队尾入队。（因为队尾删除的话需要遍历整个队列来找到前一个节点）

也可以使用双向链表来实现，这样方向就随意了。



#### Stack

- LIFO


我们可以使用数组和链表来实现栈。

实际上jdk实现的`Stack`不被推荐，因为它是使用`Vector`来实现的，也就是使用`synchronized`包装的同步类。jdk里面实际没有完全符合封装要求的栈的实现，可以用链表来做。



使用两个栈来处理运算表达式：

1.操作数进入操作数栈

2.运算符进入运算符栈

3.忽略左括号

4.遇到右括号，弹出一个运算符，弹出该运算需要数量的操作数（单目或者双目），将计算结果压入操作数栈

实际上。这个只适合于(1+(2*3))这种每次只有两个运算数，每次运算都有括号包裹的* 

如果想要计算(1*32+3)*4这样的运算式， 需要遇到运算的时候，比较和之前入栈的优先级，当前优先级低则计算之前的运算，最后运算符入栈

 需要把左括号也入栈，每次遇到右括号的时候，循环执行括号里面的内容直到peek到了左括号，最后移除左边括号



### 算法分析

```java
for i [0,N)
	for [i+1,N)	
```

统计就是：(N-1) + (N-2) + ... + 1 = N*(N-1)/2 ~ N^2



### 

```java
for i [0,N)
	for j [i+1,N)	
         for k [j+1,N)
```

统计就是：

=N(N-1)(N-2)/6



#### 动态连通问题

> 问题的输入是一列整数
> 对，其中每个整数都表示一个某种类型的对象，一对整数p
> q 可以被理解为“p 和q 是相连的”。我们假设“相连”是
> 一种等价关系，这也就意味着它具有：
>
> - 自反性：p和 p是相连的；
> - 对称性：如果p和q是相连的，那么q和p也是相连的；
> - 传递性：如果 p 和 q 是相连的且 q 和 r 是相连的，
>   那么p 和r 也是相连的。



应用：电路连通、网络通信



##### quick-find

```java
public class UnionFound {
    //id维护的是触电的值，也就是处在同一个连通分量的触点返回相同的整数值
    private int[] id;
    private int count;

    public UnionFound(int N) {
        count = N;
        //初始化数组
        id = new int[N];
        //这样初始化保证开始都不相同，也就是都是独立的触点
        for (int i = 0; i < N; i++)
            id[i] = i;
    }

    public int count() {
        return count;
    }

    public int find(int p) {
        return id[p];
    }

    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }

    //将p和q归并到相同的分量之中
    public void union(int p, int q) {
        int pId = find(p);
        int qId = find(q);

        if (pId == qId) return;

        for (int i = 0; i < id.length; i++)
            if (id[i] == pId)
                id[i] = qId;
        count--;
    }

    public static void main(String[] args) {
        UnionFound unionFound = new UnionFound(12);
        while (!StdIn.isEmpty()) {
            int p = StdIn.readInt();
            int q = StdIn.readInt();
            if (unionFound.connected(p, q)) continue;
            unionFound.union(p, q);
            System.out.println(p + " " + q);
        }
        System.out.println(unionFound.count + " components.");
    }
}
```



`union`

最好的情况，p是一个孤立的触点，那么只需要访问数组N+2次

最坏的情况，除了q其余都是p的连通点，那么访问数组N+2次，操作数组（赋值）N-1次，最后2N+1次。



至少调用N-1次`union`来全部连通：最好情况，每次都是与孤立节点操作，(N+3)(N-1)~N^2



##### quick-union

```java
    public int find(int p) {
        while (p != id[p]) p = id[p];
        return p;
    }


    //将p和q归并到相同的分量之中
    public void union(int p, int q) {
        int pRoot = find(p);
        int qRoot = find(q);

        if (pRoot == qRoot) return;

        id[pRoot] = qRoot;

        count--;
    }
```

`find()`函数最好的情况只需要访问一次，最坏2N+1（？不知道怎么搞出来的，感觉N-1差不多）

整个动态连通的最好情况是线性的，最坏的情况是平方级。



##### 关于树的概念

quick-union可以看到一种树的结构，对于树，有一些基本的概念：

- 树的**大小**是节点的数量
- 树种一个节点的**深度**是其到根节点的链接数
- 树的**高度**是所有节点的最大深度



![](.\images\树的深度和高度.png)



##### 加权quick-union算法

为了避免出现最坏的情况出现，可以记录树的大小并将较小的数连接到较大的树。

```java
    //id维护的是触电的值，也就是处在同一个连通分量的触点返回相同的整数值
    private int[] id;
    //记录深度
    private int[] height;
    private int count;

    public UnionFound3(int N) {
        count = N;
        //初始化数组
        id = new int[N];
        //这样初始化保证开始都不相同，也就是都是独立的触点
        for (int i = 0; i < N; i++)
            id[i] = i;

        //初始化每个点的深度
        height = new int[N];
        for (int i = 0; i < N; i++)
            height[i] = 1;
    }


	public int find(int p) {
        //找到根节点
        while (p != id[p]) p = id[p];
        return p;
    }
	//将p和q归并到相同的分量之中
    public void union(int p, int q) {
        int pRoot = find(p);
        int qRoot = find(q);

        if (pRoot == qRoot) return;

        //寻找高度比较低的，把低的树指向高的树
        if (height[pRoot] > height[qRoot]) {
            id[qRoot] = pRoot;
            height[pRoot] += height[qRoot];
        } else {
            id[pRoot] = qRoot;
            height[qRoot] += height[pRoot];
        }
        count--;
    }
```

在最坏的情况下，`find()`和`union()`的增长数量级为logN



 ##### 路径压缩

我们想要进一步的优化，每个节点直接链接到根节点，但不是像quick-find那样每次在union里面更新所有节点。



路径压缩的加权quick-union算法被视为最优的算法，非常接近常数

每次检查节点的同时直接链接到根节点。



```java
public class UnionFound4 {
    private int[] parent;  // parent[i] = parent of i
    private byte[] rank;   // rank[i] = rank of subtree rooted at i (never more than 31)
    private int count;     // number of components

    public UnionFound4(int n) {
        if (n < 0) throw new IllegalArgumentException();
        count = n;
        parent = new int[n];
        rank = new byte[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            rank[i] = 0;
        }
    }

    //路径压缩，找到根节点
    public int find(int p) {
        validate(p);
        while (p != parent[p]) {
            parent[p] = parent[parent[p]];    // path compression by halving
            p = parent[p];
        }
        return p;
    }

    public int count() {
        return count;
    }

    @Deprecated
    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }

    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) return;

        // make root of smaller rank point to root of larger rank
        if (rank[rootP] < rank[rootQ]) parent[rootP] = rootQ;
        else if (rank[rootP] > rank[rootQ]) parent[rootQ] = rootP;
        else {
            parent[rootQ] = rootP;
            rank[rootP]++;
        }
        count--;
    }

    private void validate(int p) {
        int n = parent.length;
        if (p < 0 || p >= n) {
            throw new IllegalArgumentException("index " + p + " is not between 0 and " + (n - 1));
        }
    }

    public static void main(String[] args) {
        int n = StdIn.readInt();
        UnionFound4 uf = new UnionFound4(n);
        while (!StdIn.isEmpty()) {
            int p = StdIn.readInt();
            int q = StdIn.readInt();
            if (uf.find(p) == uf.find(q)) continue;
            uf.union(p, q);
            StdOut.println(p + " " + q);
        }
        StdOut.println(uf.count() + " components");
    }
}
```



## 二. 排序算法

### 初级排序算法

#### 选择排序

选择排序即 **选择-交换**：遍历数组，找到最小值放在首位

(N-1)+(N-2)+1 = N(N-1)/2 ~ N^2

![](.\images\选择排序.png)



**运行时间与输入无关**：因为每次都要比较，即使是有序的数组传进去消耗的时间也一样。

**数据移动是线性的**

```java
public class SelectSort {
    public static void sort(Comparable[] a) {
        for (int i = 0; i < a.length; i++) {
            for (int j = i + 1; j < a.length; j++) {
                if (a[j].compareTo(a[i]) < 0)
                    exch(a, i, j);
            }
        }
    }
    
    public static void sort2(Comparable[] a) {
        for (int i = 0; i < a.length; i++) {
            int min = i;
            for (int j = i + 1; j < a.length; j++) {
                if (less(a[j], a[min]))
                    min = j;
            }
            if (i != min)
                exch(a, i, min);
        }
    }
    //......
}
```

选择排序每次把左边的元素（最小）固定顺序后，再依次处理右边的数据。



#### 插入排序

左边元素有序的情况下，新元素向左边排序（这个过程和冒泡排序一样，但是因为左边已经是有序的，所以实际只会处理为未排序的元素找到位置）。

![](.\images\插入排序.png)

```java
    public static void sort(Comparable[] a) {
        int N = a.length;
        for (int i = 1; i < N; i++)
            for (int j = i; j > 0 && (less(a[j], a[j - 1])); j--)
                exch(a, j, j - 1);
    }
```



插入排序的交换操作=R。

R-1+数组大小\>=比较的次数>=R



因为每次交换都改变了倒置的位置

在内层的循环里面，多次使用了交换的操作。

可以进行优化，直接把较大的元素右移：

```java
    public static void sort2(Comparable[] a) {
        int N = a.length;
        for (int i = 1; i < N; i++) {
            Comparable in = a[i];
            int j = i;
            for (; j > 0 && (less(in, a[j - 1])); j--)
                a[j] = a[j - 1];
            a[j] = in;
        }
    }
```



#### 希尔排序

依靠移动相邻元素的方式来实现排序很慢

希尔排序是改进了插入排序的**缩小增量排序**，交换不相邻的元素局部排序，然后使用插入排序对局部有序的数组排序。

也就是先把一定增量的数据视为一组进行排序，完成后不断减小增量的大小，因为插入排序本来就对有序的数组排序能减少很多的移动量。



下面参考这篇博客理解下：

[图解排序算法(二)之希尔排序](https://www.cnblogs.com/chengxiao/p/6104371.html)

![](.\images\希尔排序.png)

书上的代码是以N/3来进行分组的：

```java
    public static void sort(Comparable[] a) {
        int N = a.length;
        int h = 1;
        //获取递增序列
        //h -> 1    4   13  40  121	364
        while (h < N / 3) h = 3 * h + 1;
        while (h >= 1) {
            //和插入排序相同，但是每次遍历的组是增量确定的组，所以每次
            for (int i = h; i < N; i++) {
                for (int j = i; j >= h && less(a[j], a[j - h]); j -= h)
                    exch(a, j, j - h);
            }
            //一趟排完之后，开始缩小增量
            h = h / 3;
        }
    }
```



### 归并排序

每次递归的把数组分成两半排序

最后把结果归并

虽然时间上能够达到NlogN，但是同时因为递归栈的产生，也需要N的额外空间。



#### 原地归并

这里复制元素到aux数组，之后归并到a中。

```java
    public static void merge(Comparable[] a, int lo, int mid, int hi) {
        //i指向左边的一半
        //j指向右边的一半
        int i = lo, j = mid + 1;

        //复制数组
        for (int k = lo; k <= hi; k++)
            aux[k] = a[k];

        for (int k = lo; k <= hi; k++)
            //左边的数据取完了，剩下都取右边的数据
            if (i > mid)
                a[k] = aux[j++];
            else if (j > hi) {
                //右边的数据取完了，剩下都取左边的数据
                a[k] = aux[i++];
            } else if (less(aux[j], aux[i])) {
                //取最小的数据
                a[k] = aux[j++];
            } else {
                //取小的数据
                a[k] = aux[i++];
            }
    }
```



#### 自顶向下的归并排序（Top-down mergesort）

使用**分治**（divide and conquer）的思想可以在原地归并的基础上，通过**递归**的归并两个子数组来达到整个数组的排序。



```java
    public static void sort(Comparable[] a) {
        int N = a.length;
        aux = new Comparable[N];
        sort(a, 0, N - 1);
    }

    public static void sort(Comparable[] a, int lo, int hi) {
        if (hi < lo) return;
        int mid = (lo + hi) / 2;
        //左边排序
        sort(a, lo, mid);
        //右边排序
        sort(a, mid + 1, hi);
        //归并结果
        merge(a, lo, mid, hi);
    }
```



左边排序

sort(a, 0, 15)
	sort(a, 0, 7)
		sort(a, 0, 3)
			sort(a, 0, 1)
				merge(a, 0, 0, 1)
			sort(a, 2, 3)
				merge(a, 2, 2, 3)
			merge(a, 0, 1, 3)
	sort(a, 4, 7)
		.....
	merge(a, 0, 3, 7)



右边排序

sort(a, 8, 15)

​	.....



归并结果

merge(a, 0, 7, 15)



栈的高度lgN，每个栈的最多操作为2N次的比较

![](.\images\归并排序-自顶向下.png)







#### 自底向上的归并排序

自底向上的归并是指先把归并晓得数组，然后在合成大的数组

```java
    public static void sort(Comparable[] a) {
        int N = a.length;
        aux = new Comparable[N];
        //sz做为小数组的间隔
        for (int sz = 1; sz < N; sz += sz)
            for (int lo = 0; lo < N - sz; lo += sz + sz)
                merge(a, lo, lo + sz - 1, Math.min(lo + sz + sz - 1, N - 1));
    }
```





### 快速排序

#### 基本算法

快速排序的步骤

1. 选定基准值

2. 找到基准值位置，保证左边比其小，右边比其大（也就是正确的位置）
3. 继续对左边和右边进行排序（操作的空间很大，小数组可以使用插入排序）

```java
    public static void sort(Comparable[] a) {
        //消除输入影响
        StdRandom.shuffle(a);
        sort(a, 0, a.length - 1);
    }

    public static void sort(Comparable[] a, int lo, int hi) {
        //这里进行插入排序的优化if (hi <= lo + M) 小数组进行插入排序;
        if (hi <= lo) return;
        //确定基准值的位置（这里用a[lo]作为每次的基准值）
        int partition = partition(a, lo, hi);
        sort(a, lo, partition);
        sort(a, partition + 1, hi);
    }
```



#### 寻找基准值

设定i，j两个指针从首尾分别开始遍历，保证i左边值小于基准，j右边大于基准，遇到不符合的值互换元素。

```java
    /**
     * 使用a[lo]作为基准值，找到它对应的位置
     * 使用i，j指向头尾，如果i找到比基准大的值，就等待j右移找到比基准小的值，交换两个位置
     * （这一部分和原地递归有点像，但是不需要额外的空间，ij只是像指针的位置）
     * 最后ij重合的时候，就把i指向的值和基准值进行调换
     */
    public static int partition(Comparable[] a, int lo, int hi) {
        int i = lo;
        int j = hi + 1;

        //基准值
        Comparable v = a[lo];

        while (true) {
            //i向右遍历直到>=v的值
            while (less(a[++i], v)) if (i == hi) break;
            //j向左遍历直到<=v的值
            while (less(v, a[--j]))
                //这是冗余的，因为不可能比自己小
                if (j == lo) break;
            if (i >= j) break;
            exch(a, i, j);
        }
        //基准值和j进行交换，因为j最终指向比基准小的值
        exch(a, lo, j);
        return 1;
    }
```



#### 三向切分的快速排序

针对于数组中重复的部分，还有继续改进的空间：

因为我们之前每次比较相同的会有多余的移动，所以这里加上一个切点来处理相等的元素。

代码包含注解：

```java
	public static void sort(Comparable[] a) {
        //消除输入影响
        StdRandom.shuffle(a);
        sort(a, 0, a.length - 1);
    }
	
	public static void sort(Comparable[] a, int lo, int hi) {
        if (hi <= lo) return;
        Comparable v = a[lo];

        //[0,lt-1]<v
        int lt = lo;
        //[lt,i-1]=v
        int i = lo + 1;
        //[gt+1,hi]>v
        int gt = hi;

        while (i <= gt) {
            int compare = a[i].compareTo(v);
            if (compare > 0) exch(a, i, gt--);
            else if (compare < 0) exch(a, i++, lt++);
            else i++;
        }
        sort(a, lo, lt - 1);
        sort(a, gt + 1, hi);
    }
```





### 优先队列

考虑需要两种操作：

1. 删除最大元素
2. 插入元素

其实要求完全符合**二叉堆（最大堆）**（根节点必定大于子节点），juc包里面的`PriorityBlockingQueue`就是这么实现的（无界会考虑扩容的问题）。



应用场景：在输入巨大的情况下要求取当前的最大值



#### 初级实现

先不考虑二叉堆，思考如何来实现：

1. 无序数组：插入元素就是a[i++] = val 类似压栈的操作，删除最大元素类似选择排序找到最大值。
2. 有序数组：插入时增加操作（还是遍历右移）确保最大元素在数组右边，删除的时候直接a[size--] =null就可以了



#### 堆

在二叉堆中，每个元素都要保证大于等于另外两个特定位置的元素。

用树的角度来看，也就是每个节点都大于等于它的两个子节点。树的高度为lgN。（元素个数N=2^(h+1)，h是树的最大高度）



对于未知在k（1开始）的节点，它的子节点就是2k和2k+1，父节点就是k/2







![](.\images\二叉堆例子.png)

二叉堆的完全二叉树，数组就可以实现，如上图所示的堆，可以写成数组：

[T,S,R,P,N.....]



堆的有序化：

这里拿最大堆来说，

上浮：节点k大于父节点则交换位置（上浮）直到父节点大于k为止。

下沉：节点k小于某一个子节点，则把k与最大子节点交换位置（下沉），直到k大于所有子节点为止。

插入元素的时候，新元素k放在末尾，上浮找到位置。

删除最大元素时候，把末尾元素放在数组首位，然后下沉找到位置。

```java
   //插入
    public void insert(T v) {
        //这里需要有扩容函数
        //元素加到末尾进行上浮
        pq[++n] = v;
        swim(n);
    }

    //删除
    public T delete() {
        if (isEmpty()) throw new NoSuchElementException("empty");

        Object max = pq[1];
        //把末尾元素放到首位开始下沉
        exch(1, n--);
        sink(1);

        pq[n + 1] = null;//gc
        //删除完后可以考虑缩减容量
        return (T) max;
    }

    //上浮
    private void swim(int k) {
        //和跟节点进行比较，如果比根节点更大就上浮
        while (k > 1 && less(k / 2, k)) {
            exch(k, k / 2);
            k /= 2;
        }
    }

    //下沉
    private void sink(int k) {
        //同最大子节点进行比较，如果小于子节点就下城
        while (2 * k <= n) {
            int j = 2 * k;
            //获取较大的子节点
            if (j < n && less(j, j + 1)) j++;
            //和最大子节点比较
            if (!less(k, j)) {
                break;
            } else {
                exch(k, j);
                //继续下沉
                k = j;
            }
        }
    }
```



#### 索引优先队列

这里拿最小索引队列[`IndexMinPQ`](https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/IndexMinPQ.java.html)来看

```java
	//基本变量
    private int maxN;        // maximum number of elements on PQ
	//二叉堆的元素数量
    private int n;           // number of elements on PQ
	//二叉堆
    private int[] pq;        // binary heap using 1-based indexing
	//pq的反向记录，qp的索引是pq的值，值是pq的索引
	//用于记录元素的在二叉堆的索引位置
    private int[] qp;        // inverse of pq - qp[pq[i]] = pq[qp[i]] = i
	//记录优先级（其实就是记录元素）
    private Key[] keys;      // keys[i] = priority of i

	//构造器
    public IndexMinPQ(int maxN) {
        if (maxN < 0) throw new IllegalArgumentException();
        this.maxN = maxN;
        n = 0;
        keys = (Key[]) new Comparable[maxN + 1];    // make this of length maxN??
        pq = new int[maxN + 1];
        qp = new int[maxN + 1];                   // make this of length maxN??
        for (int i = 0; i <= maxN; i++)
            qp[i] = -1;
    }

	//这里qp[i] != -1，也就是pq里面不存在对应的值
    public boolean contains(int i) {
        validateIndex(i);
        return qp[i] != -1;
    }

	//插入元素
	public void insert(int i, Key key) {
        validateIndex(i);
        //判断元素是否已经在二叉堆中
        if (contains(i)) 
            throw new IllegalArgumentException("index is already in the priority queue");
        n++;
        //记录元素在二叉堆中的位置（初始是放在堆的末尾）
        qp[i] = n;
        //元素i放置到二叉堆中
        pq[n] = i;
        //放置元素
        keys[i] = key;
        swim(n);
    }

	//上浮元素，直到找到根节点小于元素
	private void swim(int k) {
        while (k > 1 && greater(k / 2, k)) {
            exch(k, k / 2);
            k = k / 2;
        }
    }
	
	//pq记录keys里面的索引，这里比较对应位置的元素
    private boolean greater(int i, int j) {
        return keys[pq[i]].compareTo(keys[pq[j]]) > 0;
    }

	//互换元素
	private void exch(int i, int j) {
        //pq中的元素互换
        int swap = pq[i];
        pq[i] = pq[j];
        pq[j] = swap;
        //重新记录二叉堆中的元素索引
        qp[pq[i]] = i;
        qp[pq[j]] = j;
    }

	//删除最小元素索引，返回对应索引，对应也会删除keys对应位置的元素
    public int delMin() {
        if (n == 0) throw new NoSuchElementException("Priority queue underflow");
        //二叉堆最小元素索引
        int min = pq[1];
        //需要重新使得堆有序
        //把末尾的元素放到首位
        exch(1, n--);
        //首位元素下沉
        sink(1);
        assert min == pq[n + 1];
        //删除指向pq最小索引的索引的值
        qp[min] = -1;        // delete
        //删除keys里面的元素
        keys[min] = null;    // to help with garbage collection
        //删除二叉堆中最小元素的索引
        pq[n + 1] = -1;        // not needed
        return min;
    }

	//下沉
    private void sink(int k) {
        while (2 * k <= n) {
            int j = 2 * k;
            //找到子节点最大值
            if (j < n && greater(j, j + 1)) j++;
            //比较最大子节点与当前节点
            if (!greater(k, j)) break;
            //交换元素
            exch(k, j);
            k = j;
        }
    }
```



#### 堆排序



首先需要构建堆，可以考虑

- 从左到右，使用上浮`swim()`保证左侧堆有序，就和堆插入元素是一样的
- 更高效的方法：从右到左使用下沉`sink()`操作构建子堆。



之后使用下沉排序:

- 将堆的最大元素删除，然后放入堆缩小后空出的位置。
- 除去已经排序的部分，堆的首个元素继续下沉，恢复堆有序

这样的操作类似选择排序，但是堆取出最大元素有优势。



```java
public class Heap {
    private Heap() {
    }

    public static void sort(Comparable[] pq) {
        int N = pq.length;

        //构建堆
        //从右到左，下沉根节点，这里直接从N/2开始，也就是倒数第二层
        for (int k = N / 2; k >= 1; k--)
            sink(pq, k, N);

        //排序
        //首先把最大元素取放到最右
        //然后最前面的元素堆有序（就是堆删除最大元素的操作：之前的末尾元素放在首位开始下沉）
        int k = N;
        while (k > 1) {
            exch(pq, 1, k--);
            sink(pq, 1, k);
        }
    }

    public static void sink(Comparable[] pq, int k, int n) {
        while (2 * k <= n) {
            //子节点索引
            int j = 2 * k;
            //查询子节点中最大的元素
            if (j < n && less(pq, j, j + 1)) j++;
            //比较父节点和最大子节点，小于则交换
            if (!less(pq, k, j)) break;
            exch(pq, k, j);
            k = j;
        }
    }

    private static boolean less(Comparable[] pq, int i, int j) {
        return pq[i - 1].compareTo(pq[j - 1]) < 0;
    }

    private static void exch(Object[] pq, int i, int j) {
        Object temp = pq[i - 1];
        pq[i - 1] = pq[j - 1];
        pq[j - 1] = temp;
    }
}
```





## 三. 查找

### 符号表

符号表目的在于关联**键**和**值**，有的地方也称为映射。



应用于字典、索引等。



#### 有序符号表

有序的符号表使用一组平行的数组来维护键与值。



下面是基础的API实现（实际使用会加入元素检测扩容等机制）

```java
    public Value get(Key key) {
        //找到键值对应位置
        int i = rank(key); 
        if (i < n && keys[i].compareTo(key) == 0) return vals[i];
        return null;
    } 

 	public void put(Key key, Value val)  {
        //检索位置
        int i = rank(key);

        //键值已经存在，直接覆盖
        if (i < n && keys[i].compareTo(key) == 0) {
            vals[i] = val;
            return;
        }

        //扩容（键数组以及值数组都需要扩容）
        if (n == keys.length) resize(2*keys.length);

        //键不存在，创建新的节点:
        //1.数组指定位置i后面的元素全部后移1位（n是当前元素个数）
        for (int j = n; j > i; j--)  {
            keys[j] = keys[j-1];
            vals[j] = vals[j-1];
        }
        //2.保存新的元素
        keys[i] = key;
        vals[i] = val;
        //元素个数递增
        n++;
    } 
```



#### 二分查找

上面有序符号表最关键的函数就是`rank(key)`使用二分查找检索键的位置。



关于二分查找，之前第一章实现是这样的：

```java
public int rank(Key key,int lo,int hi){
    if (hi <= lo) return lo;
    int mid = (hi + lo) / 2;
    int cmp = key.compareTo(keys[mid]);
    if ( cmp < 0 )
        return rank(key, lo , mid - 1);
    else if (cmp > 0)
        return rank(key, mid + 1, hi);
    else return mid;
}
```



我们也可以使用非递归的版本来实现：

```java
    public int rank(Key key) {
        int lo = 0, hi = n-1; 
        while (lo <= hi) { 
            int mid = lo + (hi - lo) / 2; 
            int cmp = key.compareTo(keys[mid]);
            if      (cmp < 0) hi = mid - 1; 
            else if (cmp > 0) lo = mid + 1; 
            else return mid; 
        } 
        return lo;
    } 
```



递归是使用方法栈的空间（深度lgN）来实现，循环实际上时间复杂度是一样lgN。



#### 向上和向下取

这两个函数也是从二分查找引申出来的，因为需求不一样，所以解决方案不一样：

```java
    public Key floor(Key key) {
        if (key == null) throw new IllegalArgumentException("argument to floor() is null"); 
        int i = rank(key);
        //这里取出之后，如果不是准确的位置，应该向前取一位
        if (i < n && key.compareTo(keys[i]) == 0) return keys[i];
        if (i == 0) return null;
        else return keys[i-1];
    }

    public Key ceiling(Key key) {
        if (key == null) throw new IllegalArgumentException("argument to ceiling() is null"); 
        //取到位置之后，如果合法直接返回，因为我们二分查找本来就是取的较大值
        int i = rank(key);
        if (i == n) return null; 
        else return keys[i];
    }
```





### 二叉查找树

> 定义。一棵二叉查找树（BST）是一棵二叉树，其中每个结点都含有一个Comparable 的键（以
> 及相关联的值）且每个结点的键都大于其左子树中的任意结点的键而小于右子树的任意结点
> 的键。



#### 基础结构

```java
    private Node root;             // root of BST

    private class Node {
        private Key key;           // sorted by key
        private Value val;         // associated data
        private Node left, right;  // left and right subtrees
        private int size;          // number of nodes in subtree

        public Node(Key key, Value val, int size) {
            this.key = key;
            this.val = val;
            this.size = size;
        }
    }
```





#### 查找与排序

```java
    public Value get(Key key) {
        return get(root, key);
    }

    private Value get(Node x, Key key) {
        if (key == null) throw new IllegalArgumentException("calls get() with a null key");
        if (x == null) return null;
        //二叉查找树查询：
        //查询小于根节点，查询左子树
        //查询大于根节点，查询右子树
        int cmp = key.compareTo(x.key);
        if      (cmp < 0) return get(x.left, key);
        else if (cmp > 0) return get(x.right, key);
        else              return x.val;
    }

    public void put(Key key, Value val) {
        if (key == null) throw new IllegalArgumentException("calls put() with a null key");
        root = put(root, key, val);
        assert check();
    }

    private Node put(Node x, Key key, Value val) {
        //递归基准：找到空的位置，插入元素
        if (x == null) return new Node(key, val, 1);
        
        //遍历树寻找位置
        int cmp = key.compareTo(x.key);
        if      (cmp < 0) x.left  = put(x.left,  key, val);
        else if (cmp > 0) x.right = put(x.right, key, val);
        else              x.val   = val;
        
        //更新树的元素数量
        x.size = 1 + size(x.left) + size(x.right);
        return x;
    }
```



#### 最大值和最小值

用递归和循环都是一样的：

```java
    public Key min() {
        if (isEmpty()) throw new NoSuchElementException("calls min() with empty symbol table");
        return min(root).key;
    } 

    private Node min(Node x) { 
        if (x.left == null) return x; 
        else                return min(x.left); 
    } 

    public Key max() {
        if (isEmpty()) throw new NoSuchElementException("calls max() with empty symbol table");
        return max(root).key;
    } 

    private Node max(Node x) {
        if (x.right == null) return x; 
        else                 return max(x.right); 
    } 
```



#### 排名

```java
    public int rank(Key key) {
        if (key == null) throw new IllegalArgumentException("argument to rank() is null");
        return rank(key, root);
    } 

	//查询键对应的排名
    private int rank(Key key, Node x) {
        //递归基准，找到位置
        if (x == null) return 0; 
        
        int cmp = key.compareTo(x.key);
        //没有确定位置，向左子树找
        if      (cmp < 0) return rank(key, x.left); 
        //向右子树找，此时根节点和左子树都比指定的键小，加上对应的size（元素个数）
        else if (cmp > 0) return 1 + size(x.left) + rank(key, x.right); 
        else              return size(x.left); 
    } 
```



#### 删除

如果删除最大值或者最小值，使用递归或者循环找到最左和最右的子节点删除即可。

如果删除指定节点，那么考虑它可能存在子树的情况，删除后，我们使用后继节点来填充位置（左子树的最大值或者右子树的最小值）



综合上面两点，删除节点x，我们需要：

- 保存需要删除的节点链接为t
- 将x指向min(t.right)
- x.right指向 执行了 deleteMin(t.right)操作的右子树
- x.left=t.left



