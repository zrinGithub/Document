# 算法笔记

该文档为[算法（第四版）](https://www.ituring.com.cn/book/875)笔记

参考

- [数据结构与算法](https://www.cnblogs.com/skywang12345/p/3603935.html)
- [Markdown数学公式语法](https://www.jianshu.com/p/e74eb43960a1)



下载jar包[algs4.jar](https://algs4.cs.princeton.edu/code/)

## 一.基础

### 矩阵乘法

[维基百科](http://zh.wikipedia.org/wiki/矩陣乘法)

矩阵A*B，要求矩阵A的列数和B的行数相同，可以使用向量的方式计算

```java
    public static double[][] matrixMultiplication(double[][] a, double[][] b) {
        int row = a.length;
        int col = b[0].length;
        int inner = b.length;
        double[][] result = new double[row][col];
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                for (int k = 0; k < inner; k++) {
                    result[i][j] += a[i][k] * b[k][j];
                }
            }
        }
        return result;
    }
```



### 牛顿平方根

函数f(x)=x^2-N，计算N的平方根也就是求f(x)=0的x值

倒数为2x，在n点做切线函数为g(x)=2x(x-n)+(n^2-N)  切线与x轴的交点为：

x=(n+N/n)/2

逐渐靠近计算

```java
    public static double sqrt(double c) {
        //误差范围
        double err = 1e-10;
        double t = c;
        while (Math.abs(t - c / t) > err * t)
            t = (c / t + t) / 2.0;
        return t;
    }
```



### Bag&Queue&Stack

#### Bag

- 使用链表实现

- 不支持从中删除元素的集合类型
- 像一个背包一样，遍历的时候不需要考虑元素的处理顺序

适合用于做与元素顺序无关的统计：

```java
public class BagTest {
    public static void main(String[] args) {
        Bag<Double> numbers = new Bag<Double>();
        while (!StdIn.isEmpty())
            numbers.add(StdIn.readDouble());
        int N = numbers.size();
        double sum = 0.0;
        for (double x : numbers)
            sum += x;
        //计算平均值
        double mean = sum / N;
        sum = 0.0;
        //计算每个值和平均值之差的平方和除以(N-1)后的平方根
        //这里为什么除以N-1而不是N 参考https://www.zhihu.com/question/20099757
        for (double x : numbers)
            sum += (x - mean) * (x - mean);
        double std = Math.sqrt(sum / (N - 1));
        StdOut.printf("Mean: %.2f\n", mean);
        StdOut.printf("Std dev: %.2f\n", std);
    }
}
```





#### Queue

- FIFO

可以使用单向链表来实现队列，但是只能在队尾入队。（因为队尾删除的话需要遍历整个队列来找到前一个节点）

也可以使用双向链表来实现，这样方向就随意了。



#### Stack

- LIFO


我们可以使用数组和链表来实现栈。

实际上jdk实现的`Stack`不被推荐，因为它是使用`Vector`来实现的，也就是使用`synchronized`包装的同步类。jdk里面实际没有完全符合封装要求的栈的实现，可以用链表来做。



使用两个栈来处理运算表达式：

1.操作数进入操作数栈

2.运算符进入运算符栈

3.忽略左括号

4.遇到右括号，弹出一个运算符，弹出该运算需要数量的操作数（单目或者双目），将计算结果压入操作数栈

实际上。这个只适合于(1+(2*3))这种每次只有两个运算数，每次运算都有括号包裹的* 

如果想要计算(1*32+3)*4这样的运算式， 需要遇到运算的时候，比较和之前入栈的优先级，当前优先级低则计算之前的运算，最后运算符入栈

 需要把左括号也入栈，每次遇到右括号的时候，循环执行括号里面的内容直到peek到了左括号，最后移除左边括号



### 算法分析

```java
for i [0,N)
	for [i+1,N)	
```

统计就是：(N-1) + (N-2) + ... + 1 = N*(N-1)/2 ~ N^2



### 

```java
for i [0,N)
	for j [i+1,N)	
         for k [j+1,N)
```

统计就是：

=N(N-1)(N-2)/6



#### 动态连通问题

> 问题的输入是一列整数
> 对，其中每个整数都表示一个某种类型的对象，一对整数p
> q 可以被理解为“p 和q 是相连的”。我们假设“相连”是
> 一种等价关系，这也就意味着它具有：
>
> - 自反性：p和 p是相连的；
> - 对称性：如果p和q是相连的，那么q和p也是相连的；
> - 传递性：如果 p 和 q 是相连的且 q 和 r 是相连的，
>   那么p 和r 也是相连的。



应用：电路连通、网络通信



##### quick-find

```java
public class UnionFound {
    //id维护的是触电的值，也就是处在同一个连通分量的触点返回相同的整数值
    private int[] id;
    private int count;

    public UnionFound(int N) {
        count = N;
        //初始化数组
        id = new int[N];
        //这样初始化保证开始都不相同，也就是都是独立的触点
        for (int i = 0; i < N; i++)
            id[i] = i;
    }

    public int count() {
        return count;
    }

    public int find(int p) {
        return id[p];
    }

    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }

    //将p和q归并到相同的分量之中
    public void union(int p, int q) {
        int pId = find(p);
        int qId = find(q);

        if (pId == qId) return;

        for (int i = 0; i < id.length; i++)
            if (id[i] == pId)
                id[i] = qId;
        count--;
    }

    public static void main(String[] args) {
        UnionFound unionFound = new UnionFound(12);
        while (!StdIn.isEmpty()) {
            int p = StdIn.readInt();
            int q = StdIn.readInt();
            if (unionFound.connected(p, q)) continue;
            unionFound.union(p, q);
            System.out.println(p + " " + q);
        }
        System.out.println(unionFound.count + " components.");
    }
}
```



`union`

最好的情况，p是一个孤立的触点，那么只需要访问数组N+2次

最坏的情况，除了q其余都是p的连通点，那么访问数组N+2次，操作数组（赋值）N-1次，最后2N+1次。



至少调用N-1次`union`来全部连通：最好情况，每次都是与孤立节点操作，(N+3)(N-1)~N^2



##### quick-union

```java
    public int find(int p) {
        while (p != id[p]) p = id[p];
        return p;
    }


    //将p和q归并到相同的分量之中
    public void union(int p, int q) {
        int pRoot = find(p);
        int qRoot = find(q);

        if (pRoot == qRoot) return;

        id[pRoot] = qRoot;

        count--;
    }
```

`find()`函数最好的情况只需要访问一次，最坏2N+1（？不知道怎么搞出来的，感觉N-1差不多）

整个动态连通的最好情况是线性的，最坏的情况是平方级。



##### 关于树的概念

quick-union可以看到一种树的结构，对于树，有一些基本的概念：

- 树的**大小**是节点的数量
- 树种一个节点的**深度**是其到根节点的链接数
- 树的**高度**是所有节点的最大深度



![](.\images\树的深度和高度.png)



##### 加权quick-union算法

为了避免出现最坏的情况出现，可以记录树的大小并将较小的数连接到较大的树。

```java
    //id维护的是触电的值，也就是处在同一个连通分量的触点返回相同的整数值
    private int[] id;
    //记录深度
    private int[] height;
    private int count;

    public UnionFound3(int N) {
        count = N;
        //初始化数组
        id = new int[N];
        //这样初始化保证开始都不相同，也就是都是独立的触点
        for (int i = 0; i < N; i++)
            id[i] = i;

        //初始化每个点的深度
        height = new int[N];
        for (int i = 0; i < N; i++)
            height[i] = 1;
    }


	public int find(int p) {
        //找到根节点
        while (p != id[p]) p = id[p];
        return p;
    }
	//将p和q归并到相同的分量之中
    public void union(int p, int q) {
        int pRoot = find(p);
        int qRoot = find(q);

        if (pRoot == qRoot) return;

        //寻找高度比较低的，把低的树指向高的树
        if (height[pRoot] > height[qRoot]) {
            id[qRoot] = pRoot;
            height[pRoot] += height[qRoot];
        } else {
            id[pRoot] = qRoot;
            height[qRoot] += height[pRoot];
        }
        count--;
    }
```

在最坏的情况下，`find()`和`union()`的增长数量级为logN



 ##### 路径压缩

我们想要进一步的优化，每个节点直接链接到根节点，但不是像quick-find那样每次在union里面更新所有节点。



路径压缩的加权quick-union算法被视为最优的算法，非常接近常数

每次检查节点的同时直接链接到根节点。



```java
public class UnionFound4 {
    private int[] parent;  // parent[i] = parent of i
    private byte[] rank;   // rank[i] = rank of subtree rooted at i (never more than 31)
    private int count;     // number of components

    public UnionFound4(int n) {
        if (n < 0) throw new IllegalArgumentException();
        count = n;
        parent = new int[n];
        rank = new byte[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            rank[i] = 0;
        }
    }

    //路径压缩，找到根节点
    public int find(int p) {
        validate(p);
        while (p != parent[p]) {
            parent[p] = parent[parent[p]];    // path compression by halving
            p = parent[p];
        }
        return p;
    }

    public int count() {
        return count;
    }

    @Deprecated
    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }

    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) return;

        // make root of smaller rank point to root of larger rank
        if (rank[rootP] < rank[rootQ]) parent[rootP] = rootQ;
        else if (rank[rootP] > rank[rootQ]) parent[rootQ] = rootP;
        else {
            parent[rootQ] = rootP;
            rank[rootP]++;
        }
        count--;
    }

    private void validate(int p) {
        int n = parent.length;
        if (p < 0 || p >= n) {
            throw new IllegalArgumentException("index " + p + " is not between 0 and " + (n - 1));
        }
    }

    public static void main(String[] args) {
        int n = StdIn.readInt();
        UnionFound4 uf = new UnionFound4(n);
        while (!StdIn.isEmpty()) {
            int p = StdIn.readInt();
            int q = StdIn.readInt();
            if (uf.find(p) == uf.find(q)) continue;
            uf.union(p, q);
            StdOut.println(p + " " + q);
        }
        StdOut.println(uf.count() + " components");
    }
}
```



## 二. 排序算法

### 初级排序算法

#### 选择排序

选择排序即 **选择-交换**：遍历数组，找到最小值放在首位

(N-1)+(N-2)+1 = N(N-1)/2 ~ N^2

![](.\images\选择排序.png)



**运行时间与输入无关**：因为每次都要比较，即使是有序的数组传进去消耗的时间也一样。

**数据移动是线性的**

```java
public class SelectSort {
    public static void sort(Comparable[] a) {
        for (int i = 0; i < a.length; i++) {
            for (int j = i + 1; j < a.length; j++) {
                if (a[j].compareTo(a[i]) < 0)
                    exch(a, i, j);
            }
        }
    }
    
    public static void sort2(Comparable[] a) {
        for (int i = 0; i < a.length; i++) {
            int min = i;
            for (int j = i + 1; j < a.length; j++) {
                if (less(a[j], a[min]))
                    min = j;
            }
            if (i != min)
                exch(a, i, min);
        }
    }
    //......
}
```

选择排序每次把左边的元素（最小）固定顺序后，再依次处理右边的数据。



#### 插入排序

左边元素有序的情况下，新元素向左边排序（这个过程和冒泡排序一样，但是因为左边已经是有序的，所以实际只会处理为未排序的元素找到位置）。

![](.\images\插入排序.png)

```java
    public static void sort(Comparable[] a) {
        int N = a.length;
        for (int i = 1; i < N; i++)
            for (int j = i; j > 0 && (less(a[j], a[j - 1])); j--)
                exch(a, j, j - 1);
    }
```



插入排序的交换操作=R。

R-1+数组大小\>=比较的次数>=R



因为每次交换都改变了倒置的位置

在内层的循环里面，多次使用了交换的操作。

可以进行优化，直接把较大的元素右移：

```java
    public static void sort2(Comparable[] a) {
        int N = a.length;
        for (int i = 1; i < N; i++) {
            Comparable in = a[i];
            int j = i;
            for (; j > 0 && (less(in, a[j - 1])); j--)
                a[j] = a[j - 1];
            a[j] = in;
        }
    }
```



#### 希尔排序

依靠移动相邻元素的方式来实现排序很慢

希尔排序是改进了插入排序的**缩小增量排序**，交换不相邻的元素局部排序，然后使用插入排序对局部有序的数组排序。

也就是先把一定增量的数据视为一组进行排序，完成后不断减小增量的大小，因为插入排序本来就对有序的数组排序能减少很多的移动量。



下面参考这篇博客理解下：

[图解排序算法(二)之希尔排序](https://www.cnblogs.com/chengxiao/p/6104371.html)

![](.\images\希尔排序.png)

书上的代码是以N/3来进行分组的：

```java
    public static void sort(Comparable[] a) {
        int N = a.length;
        int h = 1;
        //获取递增序列
        //h -> 1    4   13  40  121	364
        while (h < N / 3) h = 3 * h + 1;
        while (h >= 1) {
            //和插入排序相同，但是每次遍历的组是增量确定的组，所以每次
            for (int i = h; i < N; i++) {
                for (int j = i; j >= h && less(a[j], a[j - h]); j -= h)
                    exch(a, j, j - h);
            }
            //一趟排完之后，开始缩小增量
            h = h / 3;
        }
    }
```



### 归并排序

每次递归的把数组分成两半排序

最后把结果归并

虽然时间上能够达到NlogN，但是同时因为递归栈的产生，也需要N的额外空间。



#### 原地归并

这里复制元素到aux数组，之后归并到a中。

```java
    public static void merge(Comparable[] a, int lo, int mid, int hi) {
        //i指向左边的一半
        //j指向右边的一半
        int i = lo, j = mid + 1;

        //复制数组
        for (int k = lo; k <= hi; k++)
            aux[k] = a[k];

        for (int k = lo; k <= hi; k++)
            //左边的数据取完了，剩下都取右边的数据
            if (i > mid)
                a[k] = aux[j++];
            else if (j > hi) {
                //右边的数据取完了，剩下都取左边的数据
                a[k] = aux[i++];
            } else if (less(aux[j], aux[i])) {
                //取最小的数据
                a[k] = aux[j++];
            } else {
                //取小的数据
                a[k] = aux[i++];
            }
    }
```



#### 自顶向下的归并排序（Top-down mergesort）

使用**分治**（divide and conquer）的思想可以在原地归并的基础上，通过**递归**的归并两个子数组来达到整个数组的排序。



```java
    public static void sort(Comparable[] a) {
        int N = a.length;
        aux = new Comparable[N];
        sort(a, 0, N - 1);
    }

    public static void sort(Comparable[] a, int lo, int hi) {
        if (hi < lo) return;
        int mid = (lo + hi) / 2;
        //左边排序
        sort(a, lo, mid);
        //右边排序
        sort(a, mid + 1, hi);
        //归并结果
        merge(a, lo, mid, hi);
    }
```



左边排序

sort(a, 0, 15)
	sort(a, 0, 7)
		sort(a, 0, 3)
			sort(a, 0, 1)
				merge(a, 0, 0, 1)
			sort(a, 2, 3)
				merge(a, 2, 2, 3)
			merge(a, 0, 1, 3)
	sort(a, 4, 7)
		.....
	merge(a, 0, 3, 7)



右边排序

sort(a, 8, 15)

​	.....



归并结果

merge(a, 0, 7, 15)



栈的高度lgN，每个栈的最多操作为2N次的比较

![](.\images\归并排序-自顶向下.png)







#### 自底向上的归并排序

自底向上的归并是指先把归并晓得数组，然后在合成大的数组

```java
    public static void sort(Comparable[] a) {
        int N = a.length;
        aux = new Comparable[N];
        //sz做为小数组的间隔
        for (int sz = 1; sz < N; sz += sz)
            for (int lo = 0; lo < N - sz; lo += sz + sz)
                merge(a, lo, lo + sz - 1, Math.min(lo + sz + sz - 1, N - 1));
    }
```





### 快速排序

#### 基本算法

快速排序的步骤

1. 选定基准值

2. 找到基准值位置，保证左边比其小，右边比其大（也就是正确的位置）
3. 继续对左边和右边进行排序（操作的空间很大，小数组可以使用插入排序）

```java
    public static void sort(Comparable[] a) {
        //消除输入影响
        StdRandom.shuffle(a);
        sort(a, 0, a.length - 1);
    }

    public static void sort(Comparable[] a, int lo, int hi) {
        //这里进行插入排序的优化if (hi <= lo + M) 小数组进行插入排序;
        if (hi <= lo) return;
        //确定基准值的位置（这里用a[lo]作为每次的基准值）
        int partition = partition(a, lo, hi);
        sort(a, lo, partition);
        sort(a, partition + 1, hi);
    }
```



#### 寻找基准值

设定i，j两个指针从首尾分别开始遍历，保证i左边值小于基准，j右边大于基准，遇到不符合的值互换元素。

```java
    /**
     * 使用a[lo]作为基准值，找到它对应的位置
     * 使用i，j指向头尾，如果i找到比基准大的值，就等待j右移找到比基准小的值，交换两个位置
     * （这一部分和原地递归有点像，但是不需要额外的空间，ij只是像指针的位置）
     * 最后ij重合的时候，就把i指向的值和基准值进行调换
     */
    public static int partition(Comparable[] a, int lo, int hi) {
        int i = lo;
        int j = hi + 1;

        //基准值
        Comparable v = a[lo];

        while (true) {
            //i向右遍历直到>=v的值
            while (less(a[++i], v)) if (i == hi) break;
            //j向左遍历直到<=v的值
            while (less(v, a[--j]))
                //这是冗余的，因为不可能比自己小
                if (j == lo) break;
            if (i >= j) break;
            exch(a, i, j);
        }
        //基准值和j进行交换，因为j最终指向比基准小的值
        exch(a, lo, j);
        return 1;
    }
```



#### 三向切分的快速排序

针对于数组中重复的部分，还有继续改进的空间：

因为我们之前每次比较相同的会有多余的移动，所以这里加上一个切点来处理相等的元素。

代码包含注解：

```java
	public static void sort(Comparable[] a) {
        //消除输入影响
        StdRandom.shuffle(a);
        sort(a, 0, a.length - 1);
    }
	
	public static void sort(Comparable[] a, int lo, int hi) {
        if (hi <= lo) return;
        Comparable v = a[lo];

        //[0,lt-1]<v
        int lt = lo;
        //[lt,i-1]=v
        int i = lo + 1;
        //[gt+1,hi]>v
        int gt = hi;

        while (i <= gt) {
            int compare = a[i].compareTo(v);
            if (compare > 0) exch(a, i, gt--);
            else if (compare < 0) exch(a, i++, lt++);
            else i++;
        }
        sort(a, lo, lt - 1);
        sort(a, gt + 1, hi);
    }
```





### 优先队列

考虑需要两种操作：

1. 删除最大元素
2. 插入元素

其实要求完全符合**二叉堆（最大堆）**（根节点必定大于子节点），juc包里面的`PriorityBlockingQueue`就是这么实现的（无界会考虑扩容的问题）。



应用场景：在输入巨大的情况下要求取当前的最大值



#### 初级实现

先不考虑二叉堆，思考如何来实现：

1. 无序数组：插入元素就是a[i++] = val 类似压栈的操作，删除最大元素类似选择排序找到最大值。
2. 有序数组：插入时增加操作（还是遍历右移）确保最大元素在数组右边，删除的时候直接a[size--] =null就可以了



#### 堆

在二叉堆中，每个元素都要保证大于等于另外两个特定位置的元素。

用树的角度来看，也就是每个节点都大于等于它的两个子节点。树的高度为lgN。（元素个数N=2^(h+1)，h是树的最大高度）



对于未知在k（1开始）的节点，它的子节点就是2k和2k+1，父节点就是k/2







![](.\images\二叉堆例子.png)

二叉堆的完全二叉树，数组就可以实现，如上图所示的堆，可以写成数组：

[T,S,R,P,N.....]



堆的有序化：

这里拿最大堆来说，

上浮：节点k大于父节点则交换位置（上浮）直到父节点大于k为止。

下沉：节点k小于某一个子节点，则把k与最大子节点交换位置（下沉），直到k大于所有子节点为止。

插入元素的时候，新元素k放在末尾，上浮找到位置。

删除最大元素时候，把末尾元素放在数组首位，然后下沉找到位置。

```java
   //插入
    public void insert(T v) {
        //这里需要有扩容函数
        //元素加到末尾进行上浮
        pq[++n] = v;
        swim(n);
    }

    //删除
    public T delete() {
        if (isEmpty()) throw new NoSuchElementException("empty");

        Object max = pq[1];
        //把末尾元素放到首位开始下沉
        exch(1, n--);
        sink(1);

        pq[n + 1] = null;//gc
        //删除完后可以考虑缩减容量
        return (T) max;
    }

    //上浮
    private void swim(int k) {
        //和跟节点进行比较，如果比根节点更大就上浮
        while (k > 1 && less(k / 2, k)) {
            exch(k, k / 2);
            k /= 2;
        }
    }

    //下沉
    private void sink(int k) {
        //同最大子节点进行比较，如果小于子节点就下城
        while (2 * k <= n) {
            int j = 2 * k;
            //获取较大的子节点
            if (j < n && less(j, j + 1)) j++;
            //和最大子节点比较
            if (!less(k, j)) {
                break;
            } else {
                exch(k, j);
                //继续下沉
                k = j;
            }
        }
    }
```











