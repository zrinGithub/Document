# 算法笔记

该文档为[算法（第四版）](https://www.ituring.com.cn/book/875)笔记

下载jar包[algs4.jar](https://algs4.cs.princeton.edu/code/)

## 一.基础

### 矩阵乘法

[维基百科](http://zh.wikipedia.org/wiki/矩陣乘法)

矩阵A*B，要求矩阵A的列数和B的行数相同，可以使用向量的方式计算

```java
    public static double[][] matrixMultiplication(double[][] a, double[][] b) {
        int row = a.length;
        int col = b[0].length;
        int inner = b.length;
        double[][] result = new double[row][col];
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                for (int k = 0; k < inner; k++) {
                    result[i][j] += a[i][k] * b[k][j];
                }
            }
        }
        return result;
    }
```



### 牛顿平方根

函数f(x)=x^2-N，计算N的平方根也就是求f(x)=0的x值

倒数为2x，在n点做切线函数为g(x)=2x(x-n)+(n^2-N)  切线与x轴的交点为：

x=(n+N/n)/2

逐渐靠近计算

```java
    public static double sqrt(double c) {
        //误差范围
        double err = 1e-10;
        double t = c;
        while (Math.abs(t - c / t) > err * t)
            t = (c / t + t) / 2.0;
        return t;
    }
```



### Bag&Queue&Stack

#### Bag

- 使用链表实现

- 不支持从中删除元素的集合类型
- 像一个背包一样，遍历的时候不需要考虑元素的处理顺序

适合用于做与元素顺序无关的统计：

```java
public class BagTest {
    public static void main(String[] args) {
        Bag<Double> numbers = new Bag<Double>();
        while (!StdIn.isEmpty())
            numbers.add(StdIn.readDouble());
        int N = numbers.size();
        double sum = 0.0;
        for (double x : numbers)
            sum += x;
        //计算平均值
        double mean = sum / N;
        sum = 0.0;
        //计算每个值和平均值之差的平方和除以(N-1)后的平方根
        //这里为什么除以N-1而不是N 参考https://www.zhihu.com/question/20099757
        for (double x : numbers)
            sum += (x - mean) * (x - mean);
        double std = Math.sqrt(sum / (N - 1));
        StdOut.printf("Mean: %.2f\n", mean);
        StdOut.printf("Std dev: %.2f\n", std);
    }
}
```





#### Queue

- FIFO



#### Stack

- LIFO

  

使用两个栈来处理运算表达式：

1.操作数进入操作数栈

2.运算符进入运算符栈

3.忽略左括号

4.遇到右括号，弹出一个运算符，弹出该运算需要数量的操作数（单目或者双目），将计算结果压入操作数栈

实际上。这个只适合于(1+(2*3))这种每次只有两个运算数，每次运算都有括号包裹的* 

如果想要计算(1*32+3)*4这样的运算式， 需要遇到运算的时候，比较和之前入栈的优先级，当前优先级低则计算之前的运算，最后运算符入栈

 需要把左括号也入栈，每次遇到右括号的时候，循环执行括号里面的内容直到peek到了左括号，最后移除左边括号



