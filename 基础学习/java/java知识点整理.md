### 一. 知识点分析

#### 1. 介绍

- 需要掌握的知识点：

  - 掌握大厂简历投递技巧和流程，校招+社招
  - 学会编写一份适合自己的简历，中高级工程师
  - 掌握常见的HR人事必问面试题
  - 掌握新版javase核心面试题
  - 掌握JDK 集合框架核心源码+连环问面试题
  - 掌握多线程底层源码/AQS/锁设计/线程池+连环问面试题
  - 掌握消息队列连环问面试题
  - 掌握数据库索引、设计、集群搭建、分库分表等高级面试题
  - 远不止，还有更多....

  

   

 

 



#### 第5集 BAT大厂社招、校招、内推常见的面试形式有多少

**简介：讲解阿里、腾讯互联网公司常见的面试形式**

- 社招

  - 电话面试

    - 特殊时间段、公司大量招聘
    - 应聘公司的面试者不在同一城市或者跨省，比如阿里
    - 不一定是第一面、也可能第三、第四面，比如阿里的高p、腾讯的T3-2以上

  - 视频+共享桌面

    - 通过电话面试

    - 需要上机操作，考查代码能力，(一般都有线答题平台，公司内部研发、外部系统如leetcode等)

       

  - 技术现场面试

    - 如果同城一般直接现场面试
    - 或者远程面试通过
    - 现场面试一般会连续几轮，持续几小时

     

  - HR现场面试

    - 技术面通过
    - 多个技术面差不多的竞争者，进一步筛选

     

  - 发放Offer或者不通过

 

- 校招

  - 网申

    - 春招
    - 秋招

    ![image-20200301112232884](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC1%E7%AB%A0/%E7%AC%AC3%E9%9B%86/image-20200301112232884.png)

  - 流程

    - 网申(填写个人资料) -> 统一时间在线笔试 -> 多轮技术+HR面试 -> 发放offer ->实习期 -> 实习答辩 ->转正或者离职

  - 笔试和简历通过后，面试形式和社招一样

 

- 内推

  - 内推的岗位多种，实习和非实习(正式工作)
  - 方式：
    - 找师兄师姐
    - 个人人脉，比如朋友圈认识大厂的人
    - 领英、脉脉等平台
  - 对比自己投递简历的好处
    - 简历直接到技术面试官手上，更快捷
    - 对比在招聘平台上，内推更容易获得面试官认可，推荐的人也不会乱推荐
    - 可以推荐到指定的部门

   

  - 简历通过后面试形式和社招一样

 

 

 

 

 

 

 

 

 

 

 

#### 第6集 拿到面试通知，怎样应对互联网公司的多轮面试

**简介：拿到面试通知，互联网公司都有多轮面试，怎么准备**

- 面试前
  - 最好去查下公司相关产品业务、如果有app或者网站，提前去熟悉
  - 调查公司的项目，结合技术栈进行加深，也可以看公司其他招聘岗位，推断业务方向
  - 查询公司盈利能力，未来发展机会，避免公司倒闭或者发不出工资，结合网上评价
  - 公司交通位置，上下班会不会特别远，面试最好早到30分钟，不要迟到
  - 巩固面试岗位所需要的技术栈，有自己擅长的某一个领域 比如某个中间件或者框架
  - 大厂会有人才库和面试记录，尽量做足准备再去

 

- 面试中

  - 要有礼貌，保持头脑清晰，思维清晰
  - 要有自信，不能自卑或者没信心
  - 专业技术一定要准备好，尽量往自己熟悉的方向考虑，连环问
  - 做过项目一定要熟悉，准备好项目的亮点和难点
  - 有学习热情，掌握主流技术栈，关注前言技术
  - 大厂存在交叉面，方便评级和保证公平

   

- 面试后

  - 尽量可以自己总结，复盘

  - 面试多了，问题都类似，一定去补上，下次也可能遇到

  - 可以问问面试官有没回答不好的点，可以加个联系方式，多点主动联系

  - 如果有多个offer，如果不是特别缺钱，优先选择能学到技术多的，未来总会返还

     

 

 

 

 

 

 

 

#### 第7集 社招+校招被技术面试完虐系列之多方位考查点

**简介：社招和校招常见考查点**

- 为什么说会被技术官完虐，怎样避免
- 校招+社招考查点
  - 计算机编程语言基础
  - 框架(取决你熟悉的，和面试公司用的)
  - 网络
  - 算法
  - 数据库
  - 设计模式
  - 高并发、高可用
  - 分布式
  - 海量数据处理
  - 性能优化
  - 逻辑思维
  - 监控
  - 测试
  - 安全
  - 产品运营思维 ...

 

 

 

 

 

 

 

#### 第8集 互联网公司常见的HR人事面试考查问题《上》

**简介：HR面试，社招和校招常见考查点**

- 做下简单的自我介绍？

  - 尽量介绍和专业相关的，毕业、工作经历等，不能过长，尽量2分钟内

   

- 为什么从上个公司离职？

  - 不能说不好的，比如公司混乱、勾心斗角、负面情绪
  - 推荐说公司搬迁比较远，然后刚好个人职业规划对某某领域比较喜欢

   

- 你对加班的是怎么看的？

  - 业务发展好、公司快速发展，项目紧急等加班非常乐意

  - 自己也会合理评估工作，提高个人工作效率

     

- 有没女朋友，家住在哪里?

  - 考查是否上班太远了，浪费时间，且容易换工作

     

- 你对自己未来职业规划是怎样的？

  - 往专业上靠拢，比如几年发展成技术负责人，带团队，多少年称为架构师, 比较喜欢看技术书籍提升能力

 

 

 

 

 

 

 

#### 第9集 互联网公司常见的HR人事面试考查问题《下》

**简介：HR面试，社招和校招常见考查点**

 

- 你认为自己有什么缺点？
  - 不能说没有缺点
  - 避免说影响工作、让人觉得不靠谱
  - 可以说些表面上看是缺点，从工作的角度看却是优点的缺点：对事情追求比较高，比如代码洁癖爱好者，对自己做的产品比较有要求，但也会适当控制

 

- 平时有什么爱好或者兴趣？
  - 不能说抽烟喝酒啥的
  - 建议是积极向上的活动

 

- 你期望的薪资是多少?

  - 薪酬最好写个范围，也看公司具体有哪些福利，比如餐补、交通、住房补助等，是否有13薪或者其他福利

  - 然后问最终也希望公司可以根据我实际能力给工资，对双方都比较好

     

- 你还有其他问题想问的吗？

  - 公司是否有员工培训、晋升机制等
  - 自己面试是否有不足，自己好改进
  - 什么时候会有面试结果，能不能加个联系方式

 

 

 

 

 

 

 

**![logo](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/image/logo.png) 愿景："让编程不再难学，让技术与生活更加有趣"**

**更多高级架构课程请访问 xdclass.net**

### 第二章 应聘大厂工程师/技术经理的你编程基础是否牢固《上》(大厂校招+社招必备)

#### 第1集 编程语言面试题之新版javase基础语法篇之运算符《上》

**简介：面试中 短路运算符 和 位运算**

- 考点：计算机基础运算知识

- 难度【** *】

- 你知道 运算符 &和&&、|和||的区别吗？

  

  ```
  
  ```

  

  

  

  

  ```
  & 按位与操作
  ```

  ```
      只有对应的两个二进制数为1时，结果位才为1
  ```

  ```
      1&1 = 1
  ```

  ```
      1&0 = 0
  ```

  ```
      0&1 = 0
  ```

  ```
      0&0 = 0
  ```

  ```
  | 按位或操作
  ```

  ```
      有一个为1的时候，结果位就为1
  ```

  ```
      1|1 = 1
  ```

  ```
      1|0 = 1
  ```

  ```
      0|1 = 1
  ```

  ```
      0|0 = 0
  ```

  

  

  ```
  
  ```

  

  

  

  

  ```
  & 和 && 都可以实现 和 这个功能
  ```

  ```
  区别：& 两边都运算，而 && 先算 && 左侧，若左侧为false 那么右侧就不运算，判断语句中推荐使用 &&，效率更高
  ```

  ```
  
  ```

  ```
  | 和 || 和上面类似
  ```

  ```
  区别：||只要满足第一个条件，后面的条件就不再判断，而|要对所有的条件进行判断
  ```

  ```
  
  ```

  ```
  把&&和||称之为短路运算符
  ```

  

   

- 用最有效率的方法计算2乘以8



```

```









```
原理：将一个数左移n位，相当于乘以2的n次方，位运算是CPU直接支持的，所以效率高
答案：2<<3

常见的JDK源码里面HashMap的默认容量16
int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16

直接是二进制操作了，表示1左移4位，变成10000，转为10进制也就是16, 直接以二进制形式去运行，效率更高
```



 

 

 

 

 

#### 第2集 编程语言面试题之新版javase基础语法篇之运算符《下》

**简介：讲解异或运算在面试中的考查点和分析**

- 考点：计算机基础运算知识
- 难度【***】

- 写个方法，传递两个非0的int数值进去，实现变量交换的方式，有几种方式？

  - 方式一

    

    ```
    
    ```

    

    

    

    

    ```
     public static void swap(int a, int b){
    ```

    ```
    
    ```

    ```
            System.out.printf("a=%d, b=%d",a,b);
    ```

    ```
            a = a + b;
    ```

    ```
            b = a - b ;
    ```

    ```
            a = a - b;
    ```

    ```
            System.out.printf("\na=%d, b=%d",a,b);
    ```

    ```
        }
    ```

    

  - 方式二 异或运算 (一个数与另一个数异或两次是其本身， 一个数和自身异或结果是0 )

    

    ```
    
    ```

    

    

    

    

    ```
     public static void swap2(int a, int b){
    ```

    ```
    
    ```

    ```
         System.out.printf("a=%d, b=%d",a,b);
    ```

    ```
    
    ```

    ```
         a = a^b;   // a1 = a^b
    ```

    ```
         b = b^a;   // b = b^a^b
    ```

    ```
         a = a^b;   // a = a1^b = a^b^a
    ```

    ```
    
    ```

    ```
         System.out.printf("\na=%d, b=%d",a,b);
    ```

    ```
     }
    ```

    ```
     
    ```

    ```
     解释：
    ```

    ```
        a1=a^b
    ```

    ```
        b=b^a1=b^a^b=a
    ```

    ```
        //此时a1=a^b  b=a
    ```

    ```
        a=a1^b=a^b^a=b
    ```

    

     

     

#### 第3集 编程语言面试题之新版javase基础语法篇之类型

**简介：java数据类型划分**

- 考点：java基础类型的划分和运算

- 难度【**】

- 说下java数据类型分类

  - 基础数据类型：byte、short、int、long、float、double、char、boolean
  - 引用数据类型：其他都是引用类型
  - String和Enum分别是什么类型：引用类型

   

- 运算

  

  ```
  
  ```

  

  

  

  

  ```
  定义变量 int i = 5;
  ```

  ```
  return i++; 和 return ++i; 返回结果是什么
  ```

  

 

- == 和equals的区别
  - 基本数据类型比较 要用==判断是否相等
  - 引用数据类型： ==比较的是内存地址是否一样，不同对象的内存地址不一样，equals比较的是具体的内容， 也可以让开发者去定义什么条件去判断两个对象是否一样

 

 

 

 

#### 第4集 编程语言面试题之新版javase基础语法篇 try-catch-finally

**简介：try-catch-finally异常处理模块的返回值问题**

- 考点：编码规范和执行逻辑
- 难度【***】

- 下面代码 的try-catch-finally语句，try里面有个return, finally里面也有个return，结果会返回什么？为什么



```

```









```
public static int test1() {
        int a = 1;
        try {
            System.out.println(a / 0);
            a = 2;
        } catch (ArithmeticException e) {
            a = 3;
            return a; 

        } finally {
            a = 4;
        }
        return a;

    }

    public static int test2() {
        int a = 1;
        try {
            System.out.println(a / 0);
            a = 2;
        } catch (ArithmeticException e) {
            a = 3;
            return a;

        } finally {
            a = 4; 
            return a;
        }


    }
```



 

```
答案：	
	在执行try、catch中的return之前一定会执行finally中的代码（如果finally存在），如果finally中有return语句，就会直接执行finally中的return方法，所以finally中的return语句一定会被执行的

	执行流程：finally执行前的代码里面有包含return，则会先确定return返回值，然后再执行finally的代码，最后再执行return
小滴课堂 PS: 工作中项目如果这样写，猜会不会被打，不要这样写！！！
```

 

 

 

 

 

 

 

#### 第5集 编程语言面试题之新版JDK9基础语法篇 try-with-resource

**简介：新特性考察 try-with-resource 知识点**

- 考点：编程基础和是否有学习新知识特性
- 难度【** **】
- 有了解新版的JDK处理IO流吗？编写下基础代码, 从一个txt文本里面，拷贝里面的内容到另外一个txt文本里面

```
JDK7之后的写法，JDK9⼜进⾏了改良，但是变化不⼤，记住下⾯的写法即可
需要关闭的资源只要实现了java.lang.AutoCloseable，就可以⾃动被关闭
try()⾥⾯可以定义多个资源，它们的关闭顺序是最后在try()定义的资源先关闭
 try (
FileInputStream fis = new FileInputStream("/Users/xdclass/Desktop/test.txt");
BufferedInputStream bis = new BufferedInputStream(fis);
FileOutputStream fos = new FileOutputStream("/Users/xdclass/Desktop/copy.txt");
BufferedOutputStream bos = new BufferedOutputStream(fos);
 	  ) {
            int size;
            byte[] buf = new byte[1024];
            while ((size = bis.read(buf)) != -1) {
                bos.write(buf, 0, size);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
```

 

 

 

 

#### 第6集 编程语言面试题之文件API和递归考察

**简介：常见的文件API掌握，和递归算法的熟悉**

- 考点: 文件API使用，简单递归逻辑代码编写、代码编写规范，简洁性
- 难度【** **】
- 代码编写需求： 找出某目录下的所有子目录以及子文件并打印到控制台上

```
    public static void main(String[] args) {

        //找出某目录下的所有子目录以及子文件并打印到控制台上
        List<String> paths = new ArrayList<>();

        getAllFilePaths(new File("/Users/xdclass/Desktop/小滴课堂-架构面试题教程/demo"),paths);

        for(String path : paths){
            System.out.println(path);
        }


    }

    private static void getAllFilePaths(File filePath, List<String> paths) {

        File[] files =  filePath.listFiles();
        if(files == null){
            return;
        }
        for(File f : files){
            if(f.isDirectory()){
                paths.add(f.getPath());
                getAllFilePaths(f,paths);
            }else{
                paths.add(f.getPath());
            }
        }
    }
```

 

 

 

 

**![logo](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/image/logo.png) 愿景："让编程不再难学，让技术与生活更加有趣"**

**更多高级架构课程请访问 xdclass.net**

### 第三章 应聘大厂工程师/技术经理的你编程基础是否牢固《下》(大厂校招+社招必备)

 

#### 第1集 编程语言面试题之新版javase字符串（重点）

**简介：常用字符串的考查点**

- 难度【***】

- 问题1: String str = new String("xdclass.net"); 创建了几个对象？

  ```
  答案：
  
  创建一个对象：常量池存在，则直接new一个对象；
  
  创建两个对象：常量池不存在，则在常量池创建一个对象，也在堆里面创建一个对象
  ```

- 问题2: 下面是比较什么？输出结果是什么？为什么是这样的结果 String str1= new String("xdclass.net"); String str2= "xdclass.net"; String str3= "xdclass.net"; System.out.println(str1 == str2) //false System.out.println(str2 == str3) //true

```
答案：
比较引用的内存地址是否一样
第一个是false： new 创建新的对象会开辟新的空间，所以地址不一样
第二个是true：都是从常量池里面获取，"xdclass.net" 存在于常量池中
```

- 问题3： 写出下面代码的各个结果？如果需要两个都为true，应该怎么修改`

```
String s1 = "xdclass";

String s2 = s1 + ".net";  //变量 + 常量 = 来自堆

String s3 = "xdclass" + ".net";  //常量 + 常量 = 来自常亮池

System.out.println(s2 == "xdclass.net"); 

System.out.println(s3 == "xdclass.net");
答案
第一条语句打印的结果为false， s2 = s1 + ".net",   //变量+常量=堆
构建了一个新的string对象，并将对象引用赋予s2变量，常量池中的地址不一样，但是值一样。


第二条语句打印的结果为true，javac编译可以对【字符串常量】直接相加的表达式进行优化，不用等到运行期再去进行加法运算处理，而是直接将其编译成一个这些常量相连的结果.

如果需要第一个输出为true，只需要把变量改为常量即可 fianl String s1 = "xdclass";
不管是new String("XXX")和直接常量赋值, 都会在字符串常量池创建.只是new String("XXX")方式会在堆中创建一个对象去指向常量池的对象, 普通的常量赋值是直接赋值给变量
```

 

 

 

 

 

#### 第2集 编程语言面试题之新版javase字符串相关构建类

**简介：常用字符串相关构建类的使用好区别**

- 考点：是否有举一反三的思维，常用类的掌握情况

- 难度【***】

- 问：String、StringBuffer与StringBuilder的区别？分别在哪些场景下使用

- 答案：

  ```
  三者都是final， 不允许被继承
  在本质都是char[]字符数组实现
  String、StringBuffer与StringBuilder中，String是不可变对象，另外两个是可变的
  ```

  ```
  StringBuilder 效率更快，因为它不需要加锁，不具备多线程安全
  
  StringBuffer里面操作方法用synchronized ，效率相对更低,是线程安全的；
  
  使用场景：
  	操作少量的数据用String，但是常改变内容且操作数据多情况下最好不要用 String ，因为每次生成中间对象性能会降低
  
  	单线程下操作大量的字符串用StringBuilder，虽然线程不安全但是不影响
  
  	多线程下操作大量的字符串，且需要保证线程安全 则用StringBuffer
  ```

   

 

 

 

 

 

#### 第3集 编程语言面试题之新版javase面向对象篇

**简介：面向对象思想OOP**

- 考点：面向对象思想OOP的理解

- 难度【***】

- 面向对象的四大特性是？分别解释下

  ```
  答案：
  	抽象
  		关键词abstract声明的类叫作抽象类，abstract声明的⽅法叫抽象⽅法
          ⼀个类⾥包含了⼀个或多个抽象⽅法，类就必须指定成抽象类
          抽象⽅法属于⼀种特殊⽅法，只含有⼀个声明，没有⽅法体
  		抽象支付  
  			pay(金额，订单号)，默认实现是本地支付，微信支付，支付宝支付，银行卡支付
  		
  	
  	封装
  		封装是把过程和数据包围起来，对数据的访问只能通过已定义的接⼝即⽅法
          在java中通过关键字private，protected和public实现封装。
          封装把对象的所有组成部分组合在⼀起，封装定义程序如何引⽤对象的数据，
          封装实际上使⽤⽅法将类的数据隐藏起来，控制⽤户对类的修改和访问数据的程度。 适当的
          封装可以让代码更容易理解和维护，也加强了代码的安全性
          类封装
          ⽅法封装
  	
  	继承
  		⼦类继承⽗类的特征和⾏为，使得⼦类对象具有⽗类的⽅法和属性，⽗类也叫基类，具有公共的⽅法和属性
          动物<-猫
          动物<-狗
          abstract class AbsPay{
  
  		}
  		
  		WeixinPay extends AbsPay{
              
  		}
  		
  		AliPay extends AbsPay{
              
  		}
  		
  	多态
  		同⼀个⾏为具有多个不同表现形式的能⼒
          优点：减少耦合、灵活可拓展
          ⼀般是继承类或者重写⽅法实现
  ```

   

 

 

 

 

#### 第4集 编程语言面试题之新版javase接口篇

**简介：讲解接口常见面试题，新版JDK8**

- 考点：基础是否扎实和常用语言是否有了解新语法

- 难度【***】

- Overload和Override的区别？

  ```
  重载Overload：表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同，参数个数或类型不同
  重写Override：表示子类中的方法可以与父类中的某个方法的名称和参数完全相同
  ```

 

- 接口是否可以继承接口？接口是否支持多继承？类是否支持多继承？接口里面是否可以有方法实现

  - 接⼝⾥可以有静态⽅法和⽅法体
  - 接⼝中所有的⽅法必须是抽象⽅法（JDK8之后就不是）
  - 接⼝不是被类继承了，⽽是要被类实现
  - 接⼝⽀持多继承, 类不⽀持多个类继承

  ⼀个类只能继承⼀个类，但是能实现多个接⼝,接⼝能继承另⼀个接⼝，接⼝的继承使⽤extends关键字，和类继承⼀样

   

- 是否了解JDK8里面接口新特性

  - interface中可以有static⽅法，但必须有⽅法实现体，该⽅法只属于该接⼝，接⼝名直接调⽤ 该⽅法
  - 接⼝中新增default关键字修饰的⽅法，default⽅法只能定义在接⼝中，可以在⼦类或⼦接⼝ 中被重写default定义的⽅法必须有⽅法体
  - ⽗接⼝的default⽅法如果在⼦接⼝或⼦类被重写，那么⼦接⼝实现对象、⼦类对象，调⽤该 ⽅法，以重写为准
  - 本类、接⼝如果没有重写⽗类（即接⼝）的default⽅法，则在调⽤default⽅法时，使⽤⽗类（接口） 定义的default⽅法逻辑

 

 

 

 

**![logo](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/image/logo.png) 愿景："让编程不再难学，让技术与生活更加有趣"**

**更多高级架构课程请访问 xdclass.net**

### 第四章 阿里p6后端工程师/技术经理的java集合框架List了解多少

 

#### 第1集 编程语言面试题之新版javase集合框架List基础篇

**简介：java集合框架里面List常见基础面试题**

- 考查点：list的基础知识点掌握情况，对应的实现的区别，线程安全、使用场景
- 难度【***】
- 说下Vector和ArrayList、LinkedList联系和区别？分别的使用场景
- 答案：
  - 线程安全
    - ArrayList：底层是数组实现，线程不安全，查询和修改非常快，但是增加和删除慢
    - LinkedList: 底层是双向链表，线程不安全，查询和修改速度慢，但是增加和删除速度快
    - Vector: 底层是数组实现，线程安全的，操作的时候使用synchronized进行加锁
  - 使用场景
    - Vector已经很少用了
    - 增加和删除场景多则用LinkedList
    - 查询和修改多则用ArrayList

 

 

#### 第2集 编程语言面试题之新版javase集合框架List 追杀篇《上》

**简介：基于List进行继续追问，初试连环炮**

- 考点: List的掌握情况（追问系列）
- 难度【***】
- 如果需要保证线程安全，ArrayList应该怎么做，用有几种方式

```
方式一：自己写个包装类，根据业务一般是add/update/remove加锁 

方式二：Collections.synchronizedList(new ArrayList<>()); 使用synchronized加锁

方式三：CopyOnWriteArrayList<>()  使用ReentrantLock加锁
```

 

 

 

 

 

 

 

 

 

 

 

 

#### 第3集 编程语言面试题之CopyOnWriteArrayList追杀篇《下》

**简介：基于CopyOnWriteArrayList进行继续追问**

- 考点: CopyOnWriteArrayList的掌握情况（追问系列）

- 难度【** ***】

- 如果回答到上面的点则继续问，没回到到则问，了解CopyOnWriteArrayList吗？和 Collections.synchronizedList实现线程安全有什么区别, 使用场景是怎样的？

  - CopyOnWriteArrayList：执行修改操作时，会拷贝一份新的数组进行操作（add、set、remove等)，代价十分昂贵，在执行完修改后将原来集合指向新的集合来完成修改操作，源码里面用ReentrantLock可重入锁来保证不会有多个线程同时拷贝一份数组

    - 场景：读高性能，适用读操作远远大于写操作的场景中使用(读的时候是不需要加锁的，直接获取，删除和增加是需要加锁的, 读多写少)

     

  - Collections.synchronizedList：线程安全的原因是因为它几乎在每个方法中都使用了synchronized同步*锁

    - 场景：写操作性能比CopyOnWriteArrayList好，读操作性能并不如CopyOnWriteArrayList

   

- CopyOnWriteArrayList的设计思想是怎样的,有什么缺点？

  答案：设计思想：读写分离+最终一致

  缺点：内存占用问题,写时复制机制,内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象,如果对象大则容易发生Yong GC和Full GC

 

 

 

 

#### 第4集 源码剖析之新版javase扩容机制List暗器篇

**简介：基于List进行继续二次追问，进阶扩容机制+源码剖析**

- 考点：List集合扩容机制
- 难度【** * **】

- 说下ArrayList的扩容机制是怎样的

  ```
  注意：JDK1.7之前ArrayList默认大小是10，JDk1.7之后是0
  
  未指定集合容量，默认是0，若已经指定大小则集合大小为指定的；
  当集合第一次添加元素的时候，集合大小扩容为10
  ArrayList的元素个数大于其容量，扩容的大小= 原始大小+原始大小/2
  ```

 

- 源码解读 JDK ArrayList 扩容核心源码

 

```
调试代码

List<String> list = new ArrayList<>();

for(int i=0;i<10;i++){
    list.add(""+i);
}
System.out.println(list.size());

list.add("xdclass.net");

System.out.println(list.size());
```

 

 

 

#### 第5集 编程语言面试题之新版JDK手写ArrayList大招篇《上》

**简介：基于List进行继续追问，进阶连环炮，代码实战**

- 考点：源码设计思想、代码编写规范
- 难度【** * **】
- 设计一个简单的ArrayList【需要包含 构造函数(有参和无参)、add(obj)、 扩容机制】

```
 //计算容量+确保容量
    private void ensureCapacityInternal(int minCapacity){

        //如果是初次扩容，则使用默认的容量
        if(elementData == EMPTY_ELEMENT_DATA){
            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
        }

        //是否需要扩容，需要的最少容量大于现在数组的长度则要扩容
        if(minCapacity - elementData.length > 0){
            int oldCapacity = elementData.length;

            int newCapacity = oldCapacity + (oldCapacity>>1);

            //如果新容量 < 最小容量， 则讲最新的容量赋值给新的容量
            if(newCapacity - minCapacity < 0){
                newCapacity = minCapacity;
            }

            //创建新数组
            Object[] objects = new Object[newCapacity];

            //将旧的数组复制到新的数组里面
            System.arraycopy(elementData,0, objects,0,elementData.length);

            //修改引用
            elementData = objects;

        }

    }
```

 

 

 

 

 

 

 

#### 第6集 编程语言面试题之新版JDK手写ArrayList大招篇《下》

**简介：基于List进行继续追问，进阶连环炮，代码实战**

- 考点：源码设计思想、代码编写规范
- 难度【** * **】
- 设计一个简单的ArrayList【remove(index)、get(index) 、indexOf(o) ,set(int index,Object obj)】

 

```
System.arraycopy(Object src, int srcPos, Object dest, int destPos,int length)参数介绍

Object src : 原数组
int srcPos : 从元数据的起始位置开始
Object dest : 目标数组
int destPos : 目标数组的开始起始位置
int length  : 要copy的数组的长度
```

 

 

 

 

 

 

**![logo](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/image/logo.png) 愿景："让编程不再难学，让技术与生活更加有趣"**

**更多高级架构课程请访问 xdclass.net**

### 第五章 面试BAT高级工程师/技术经理的java集合框架Map了解多少

#### 第1集 编程语言面试题之新版javase集合框架Map篇<小试牛刀上>

**简介：集合框架里面基础Map面试题**

- 考点：Map 相关基础知识掌握情况
- 难度【***】

- 了解Map吗？用过哪些Map的实现 答：HashMap、Hashtable、LinkedHashMap、TreeMap、ConcurrentHashMap

   

- 说下 HashMap和Hashtable 的区别

  答：

  - HashMap：底层是基于数组+链表，非线程安全的，默认容量是16、允许有空的健和值
  - Hashtable：基于哈希表实现，线程安全的(加了synchronized)，默认容量是11，不允许有null的健和值

 

 

 

 

 

#### 第2集 编程语言面试题之对象底层HashCode和equals掌握了吗

**简介：对象的比较、排重 hashcode和equals经常需要重写，也是map和set里面常用知识**

- 考点：hashcode和equals掌握情况

- 难度【** **】

- 介绍下对象的 hashCode()和equals()，使用场景

  ```
  hashcode
  	顶级类Object里面的方法，所有的类都是继承Object,返回是一个int类型的数
  	根据一定的hash规则(存储地址，字段，长度等)，映射成一个数组，即散列值
  	
  equals
  	顶级类Object里面的方法，所有的类都是继承Object,返回是一个boolean类型
  	根据自定义的匹配规则，用于匹配两个对象是否一样，一般逻辑如下
  	//判断地址是否一样
  	//非空判断和Class类型判断
  	//强转
  	//对象里面的字段一一匹配
  
  使用场景：对象比较、或者集合容器里面排重、比较、排序
  ```

   

 

- 代码实战: 编写一个User对象，重写里面的hashcode和equal方法

  ```
  import java.util.Date;
  import java.util.Objects;
  
  public class User {
  
      private int age;
  
      private  String name;
  
      private Date time;
  
      public int getAge() {
          return age;
      }
  
      public void setAge(int age) {
          this.age = age;
      }
  
      public String getName() {
          return name;
      }
  
      public void setName(String name) {
          this.name = name;
      }
  
      public Date getTime() {
          return time;
      }
  
      public void setTime(Date time) {
          this.time = time;
      }
  
  
      @Override
      public int hashCode() {
  
          //int code = age/name.length()+time.hashCode();
          //return code
  
          return Objects.hash(age,name,time);
  
      }
  
      @Override
      public boolean equals(Object obj) {
  
          if(this == obj) return true;
  
          if(obj == null || getClass() != obj.getClass()) return false;
  
          User user = (User) obj;
  
          return age == user.age && Objects.equals(name, user.name) && Objects.equals(time, user.time);
  
      }
  }
  ```

   

 

 

 

 

#### 第3集 编程语言面试题之新版javase集合框架Map篇<小试牛刀下>

**简介：集合框架里面基础Map面试题**

- 考点：Map 相关基础知识掌握情况

- 难度【***】

- HashMap和TreeMap应该怎么选择，使用场景

  ```
  hashMap: 散列桶(数组+链表)，可以实现快速的存储和检索，但是确实包含无序的元素，适用于在map中插入删除和定位元素
  
  treeMap:使用存储结构是一个平衡二叉树->红黑树，可以自定义排序规则，要实现Comparator接口
  能便捷的实现内部元素的各种排序，但是一般性能比HashMap差，适用于安装自然排序或者自定义排序规则
  (写过微信支付签名工具类就用这个类)
  ```

- Set和Map的关系

  ```
  核心就是不保存重复的元素，存储一组唯一的对象
  set的每一种实现都是对应Map里面的一种封装，
  HashSet对应的就是HashMap，treeSet对应的就是treeMap
  ```

- 常见Map的排序规则是怎样的？

  ```
  按照添加顺序使用LinkedHashMap，按照自然排序使用TreeMap，自定义排序 TreeMap(Comparetor c)
  ```

   

 

 

#### 第4集 编程语言面试题之新版javase集合框架Map篇<进阶>

**简介：集合框架里面基础Map面试题进阶**

- 考点：考查Map的横向和纵向知识点
- 难度【** **】

- 如果需要线程安全，且效率高的Map，应该怎么做？

  答案：多线程环境下可以用concurrent包下的ConcurrentHashMap, 或者使用Collections.synchronizedMap(),

  ConcurrentHashMap虽然是线程安全，但是他的效率比Hashtable要高很多

   

- 为什么Collections.synchronizedMap后是线程安全的？

  答案：使用Collections.synchronizedMap包装后返回的map是加锁的

 

 

 

 

 

 

#### 第5集 编程语言面试题之新版javase集合框架Map高手篇<上>

**简介：深入底层HashMap实现原理**

- 考点：是否掌握HashMap的底层实现
- 难度【** **】
- 看过HashMap源码吗，介绍下你了解的HashMap

```
答案：
	看过源码
	
	HashMap底层(数组+链表+红黑树 jdk8才有红黑树)
	
	数组中每一项是一个链表，即数组和链表的结合体
	
	Node<K,V>[] table 是数组，数组的元素是Entry(Node继承Entry)，Entry元素是一个key-value的键值对，它持有一个指向下个Entry的引用，table数组的每个Entry元素同时也作为当前Entry链表的首节点，也指向了该链表的下个Entry元素
	
	在JDK1.8中，链表的长度大于8，链表会转换成红黑树
```

![image-20200131220936679](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC5%E7%AB%A0/%E7%AC%AC5%E9%9B%86/image-20200131220936679.png)

- 能否解释下什么是Hash碰撞？常见的解决办法有哪些，hashmap采用哪种方法

  ```
  答：
  	hash碰撞的意思是不同key计算得到的Hash值相同，需要放到同个bucket中
  	
  	常见的解决办法：链表法、开发地址法、再哈希法等
  	
  	HashMap采用的是链表法
  ```

 

 

 

 

 

 

 

 

#### 第6集 编程语言面试题之新版javase集合框架Map高手篇<中>

**简介：深入底层HashMap实现原理**

- 考点：是否掌握HashMap的底层实现
- 难度【** * **】

- 你说HashMap底层是 数组+链表+红黑树，为什么要用这几类结构呢？

  ```
   答案：
   数组 Node<K,V>[] table ，根据对象的key的hash值进行在数组里面是哪个节点
   
   链表的作用是解决hash冲突，将hash值一样的对象存在一个链表放在hash值对应的槽位
   
   红黑树 JDK8使用红黑树来替代超过8个节点的链表，主要是查询性能的提升，从原来的O(n)到O(logn),
   通过hash碰撞，让HashMap不断产生碰撞，那么相同的key的位置的链表就会不断增长，当对这个Hashmap的相应位置进行查询的时候，就会循环遍历这个超级大的链表，性能就会下降，所以改用红黑树
   
  ```

  ![image-20200131220936679](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC5%E7%AB%A0/%E7%AC%AC5%E9%9B%86/image-20200131220936679.png)

- 为啥选择红黑树而不用其他树，比如二叉查找树，为啥不一直开始就用红黑树，而是到8的长度后才变换

```
答案：二叉查找树在特殊情况下也会变成一条线性结构，和原先的链表存在一样的深度遍历问题，查找性能就会慢，
使用红黑树主要是提升查找数据的速度，红黑树是平衡二叉树的一种，插入新数据后会通过左旋，右旋、变色等操作来保持平衡，解决单链表查询深度的问题

数据量少的时候操作数据，遍历线性表比红黑树所消耗的资源少，且前期数据少 平衡二叉树保持平衡是需要消耗资源的，所以前期采用线性表，等到一定数之后变换到红黑树
```

![image-20200201151450172](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC5%E7%AB%A0/%E7%AC%AC7%E9%9B%86/%E7%BA%A2%E9%BB%91%E6%A0%91%E4%BE%8B%E5%AD%90.png)

 

 

 

 

 

#### 第7集 源码剖析之深入新版HashMap高手篇<下>

**简介：深入底层HashMap实现原理，分析put、get源码实现**

- 考点：是否掌握HashMap的底层实现，put、get流程

- 难度【** ** **】

- 说下hashmap的put和get的核心逻辑（JDK8以上版本）

  - put核心流程，看图（高清图看资料里面，第5章第7集文件夹里面的html文件）

    ![image-20200201151131252](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC5%E7%AB%A0/%E7%AC%AC5%E9%9B%86/image-20200201151131252.png)

  - get核心流程

    ```
     final Node<K,V> getNode(int hash, Object key) {
            Node<K,V>[] tab; Node<K,V> first, e; int n; K k;
            if ((tab = table) != null && (n = tab.length) > 0 &&
                (first = tab[(n - 1) & hash]) != null) {
                //获取首节点，hash碰撞概览小，通常链表第一个节点就是值，没必要去循环遍历，处于效率
                if (first.hash == hash && // always check first node
                    ((k = first.key) == key || (key != null && key.equals(k))))
                    return first;
                //如果不止一个节点，就需要循环遍历，存在多个hash碰撞    
                if ((e = first.next) != null) {
                	//判断是否是红黑树，如果是则调用树的查找
                    if (first instanceof TreeNode)
                        return ((TreeNode<K,V>)first).getTreeNode(hash, key);
                    //链表结构，则循环遍历获取节点
                    do {
                        if (e.hash == hash &&
                            ((k = e.key) == key || (key != null && key.equals(k))))
                            return e;
                    } while ((e = e.next) != null);
                }
            }
            return null;
        }
    ```

     

 

 

 

 

 

#### 第8集 编程语言面试题之新版javase集合框架ConcurrentHashMap篇

**简介：并发包里面ConcurrentHashMap面试题**

- 考点：是否掌握并发包下的ConcurrentHashMap基础和原理

- 难度【** **】

- 了解ConcurrentHashMap吗？为什么性能比hashtable高，说下原理

  ```
  ConcurrentHashMap线程安全的Map, hashtable类基本上所有的方法都是采用synchronized进行线程安全控制
  高并发情况下效率就降低
  
  ConcurrentHashMap是采用了分段锁的思想提高性能，锁粒度更细化
  ```

   

- jdk1.7和jdk1.8里面ConcurrentHashMap实现的区别有没了解

  ```
  JDK8之前，ConcurrentHashMap使用锁分段技术，将数据分成一段段存储，每个数据段配置一把锁，即segment类，这个类继承ReentrantLock来保证线程安全
  技术点：Segment+HashEntry
  
  JKD8的版本取消Segment这个分段锁数据结构，底层也是使用Node数组+链表+红黑树，从而实现对每一段数据就行加锁，也减少了并发冲突的概率，CAS(读)+Synchronized(写)
  技术点：Node+Cas+Synchronized
  ```

   

   

 

#### 第9集 源码剖析之深入新版ConcurrentHashMap篇

**简介：解读并发包里面ConcurrentHashMap核心Put源码**

 

- 考点：是否掌握并发包下的ConcurrentHashMap基础和原理

- 难度【** **】

- 说下ConcurrentHashMap的put的核心逻辑（JDK8以上版本）

  ```
  spread(key.hashCode())  重哈希，减少碰撞概率
  tabAt(i) 获取table中索引为i的Node元素
  casTabAt(i) 利用CAS操作获取table中索引为i的Node元素
  
  
  put的核心流程
  1、key进行重哈希spread(key.hashCode())
  2、对当前table进行无条件循环
  3、如果没有初始化table，则用initTable进行初始化
  4、如果没有hash冲突，则直接用cas插入新节点，成功后则直接判断是否需要扩容，然后结束
  5、(fh = f.hash) == MOVED 如果是这个状态则是扩容操作，先进行扩容
  6、存在hash冲突，利用synchronized (f) 加锁保证线程安全
  7、如果是链表，则直接遍历插入，如果数量大于8，则需要转换成红黑树
  8、如果是红黑树则按照红黑树规则插入
  9、最后是检查是否需要扩容addCount()
  ```

   

推荐资料：

https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html

https://www.jianshu.com/p/5dbaa6707017

 

 

 

**![logo](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/image/logo.png) 愿景："让编程不再难学，让技术与生活更加有趣"**

**更多高级架构课程请访问 xdclass.net**

### 第六章 面试必备知识之玩转并发编程技术点

#### 第1集 多年开发经验的你是否知道线程+进程+协程的区别

**简介：是否掌握线程、进程、协程的区别**

- 考点：是否掌握线程、进程、协程的区别

- 难度【***】

- 能否解释下什么是进程、线程、协程，他们之间的关系是怎样的

  ```
  答案：
  进程: 本质上是一个独立执行的程序，进程是操作系统进行资源分配和调度的基本概念，操作系统进行资源分配和调度的一个独立单位
  
  线程:是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一个进程中可以并发多个线程，每条线程执行不同的任务，切换受系统控制。
  
  协程: 又称为微线程，是一种用户态的轻量级线程，协程不像线程和进程需要进行系统内核上的上下文切换，协程的上下文切换是由用户自己决定的，有自己的上下文，所以说是轻量级的线程，也称之为用户级别的线程就叫协程，一个线程可以多个协程,线程进程都是同步机制，而协程则是异步 
  Java的原生语法中并没有实现协程,目前python、Lua和GO等语言支持
  
  关系：一个进程可以有多个线程，它允许计算机同时运行两个或多个程序。线程是进程的最小执行单位，CPU的调度切换的是进程和线程，进程和线程多了之后调度会消耗大量的CPU，CPU上真正运行的是线程，线程可以对应多个协程
  ```

   

- 协程对于多线程有什么优缺点吗

- 难度【***】

  ```
  优点：
  	非常快速的上下文切换，不用系统内核的上下文切换，减小开销
  	单线程即可实现高并发，单核CPU可以支持上万的协程
  	由于只有一个线程，也不存在同时写变量的冲突，在协程中控制共享资源不需要加锁
  缺点：
  	协程无法利用多核资源，本质也是个单线程
  	协程需要和进程配合才能运行在多CPU上
  	目前java没成熟的第三方库，存在风险
  	调试debug存在难度，不利于发现问题
  ```

 

 

 

#### 第2集 多年开发经验的你是否可以清晰表达 并发、并行的区别

**简介：是否清晰表达并发+并行的区别**

- 考点：计算机基础并发、并行概念

- 难度【**】

- 说下并发和并行的区别，举些例子说下

  ```
  并发 concurrency：
  一台处理器上同时处理任务, 这个同时实际上是交替处理多个任务，程序中可以同时拥有两个或者多个线程，当有多个线程在操作时,如果系统只有一个CPU,则它根本不可能真正同时进行一个以上的线程,它只能把CPU运行时间划分成若干个时间段,再将时间段分配给各个线程执行
  
  并行 parallellism：
  	多个CPU上同时处理多个任务，一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行
  		
  并发指在一段时间内宏观上去处理多个任务。  并行指同一个时刻，多个任务确实真的同时运行。	
  
  例子：
  并发是一心多用，听课和看电影，但是CPU大脑只有一个，所以轮着来
  并行：火影忍者中的影分身，有多个你出现，可以分别做不同的事情
  
  一个项目经理A和3个程序B C D的故事
  单线程
  并发：A给B讲完需求，B自己去实现，期间A继续给C和D讲，不用等待某个程序员去完成，期间项目经理没空闲下来
  并行：直接找3个项目经理分别分配给3个程序员
  ```

 

#### 第3集 新版Java多线程的实现方式你知道多少《上》

**简介: Java多线程的实现方式和区别**

- 考点：java多线程基础知识

- 难度：【***】

- 你知道java里面实现多线程有哪几种方式，有什么不同，比较常用哪种

  - 继承Thread

  - ```
    继承Thread，重写里面run方法，创建实例，执行start
    优点：代码编写最简单直接操作
    缺点：没返回值，继承一个类后，没法继承其他的类，拓展性差
    
    public class ThreadDemo1 extends Thread {
        @Override
        public void run() {
            System.out.println("继承Thread实现多线程，名称："+Thread.currentThread().getName());
        }
    }
    
    
    
    public static void main(String[] args) {
    
          ThreadDemo1 threadDemo1 = new ThreadDemo1();
          threadDemo1.setName("demo1");
          threadDemo1.start();
          System.out.println("主线程名称："+Thread.currentThread().getName());
    
    }
    ```

  - 实现Runnable

  - ```
    自定义类实现Runnable，实现里面run方法，创建Thread类，使用Runnable接口的实现对象作为参数传递给Thread对象，调用Strat方法
    
    优点：线程类可以实现多个几接口，可以再继承一个类
    缺点：没返回值，不能直接启动，需要通过构造一个Thread实例传递进去启动
    
    
    public class ThreadDemo2 implements Runnable {
    
        @Override
        public void run() {
            System.out.println("通过Runnable实现多线程，名称："+Thread.currentThread().getName());
        }
    }
    
    
    
    public static void main(String[] args) {
            ThreadDemo2 threadDemo2 = new ThreadDemo2();
            Thread thread = new Thread(threadDemo2);
            thread.setName("demo2");
            thread.start();
            System.out.println("主线程名称："+Thread.currentThread().getName());
    }
    
    
    
    
    JDK8之后采用lambda表达式
    public static void main(String[] args) {
        Thread thread = new Thread(()->{
                    System.out.println("通过Runnable实现多线程，名称："+Thread.currentThread().getName());
                });
        thread.setName("demo2");
        thread.start();
        System.out.println("主线程名称："+Thread.currentThread().getName());
    }
    ```

     

   

 

#### 第4集 新版Java多线程的实现方式你知道多少《下》

**简介: Java多线程的实现方式和区别**

- 考点：java多线程基础知识

- 难度：【** **】

- 你知道java里面实现多线程有哪几种方式，有什么不同，比较常用哪种

  - 通过Callable和FutureTask方式

  - ```
    创建callable接口的实现类，并实现call方法，结合FutureTask类包装Callable对象，实现多线程
    优点：有返回值，拓展性也高
    缺点：jdk5以后才支持，需要重写call方法，结合多个类比如FutureTask和Thread类
    
    
    public class MyTask implements Callable<Object> {
        @Override
        public Object call() throws Exception {
    
            System.out.println("通过Callable实现多线程，名称："+Thread.currentThread().getName());
    
            return "这是返回值";
        }
    }
    
     public static void main(String[] args) {
    
    
            FutureTask<Object> futureTask = new FutureTask<>(()->{
                System.out.println("通过Callable实现多线程，名称："+Thread.currentThread().getName());
                return "这是返回值";
            });
    
    
    //        MyTask myTask = new MyTask();
    //        FutureTask<Object> futureTask = new FutureTask<>(myTask);
    
            //FutureTask继承了Runnable，可以放在Thread中启动执行
            Thread thread = new Thread(futureTask);
            thread.setName("demo3");
            thread.start();
            System.out.println("主线程名称:"+Thread.currentThread().getName());
    
            try {
    
                System.out.println(futureTask.get());
    
            } catch (InterruptedException e) {
                //阻塞等待中被中断，则抛出
                e.printStackTrace();
            } catch (ExecutionException e) {
    
                //执行过程发送异常被抛出
                e.printStackTrace();
            }
    
    
        }
    ```

  - 通过线程池创建线程

  - ```
    自定义Runnable接口，实现run方法，创建线程池，调用执行方法并传入对象
    优点：安全高性能，复用线程
    缺点: jdk5后才支持，需要结合Runnable进行使用
    
    
    public class ThreadDemo4 implements Runnable {
    
        @Override
        public void run() {
            System.out.println("通过线程池+runnable实现多线程，名称："+Thread.currentThread().getName());
        }
    }
    
    
    public static void main(String[] args) {
            ExecutorService executorService = Executors.newFixedThreadPool(3);
    
            for(int i=0;i<10;i++){
                executorService.execute(new ThreadDemo4());
            }
    
    
            System.out.println("主线程名称:"+Thread.currentThread().getName());
    
            //关闭线程池
            executorService.shutdown();
    }
    ```

 

- 一般常用的Runnable 和 第四种线程池+Runnable，简单方便扩展，和高性能 (池化的思想)

 

 

 

 

 

 

#### 第5集 新版Java线程的状态你知道多少？

**简介：线程有几种状态有哪些，分别解释下**

- 考点：是否掌握线程常见的状态

- 难度：【**】

- java线程常见的基本状态有哪些，这些状态分别是做什么的

  ```
  JDK的线程状态分6种，JVM里面9种，我们一般说JDK的线程状态
  
  常见的5种状态
  
  创建(NEW): 生成线程对象，但是并没有调用该对象start(), new Thread()
  
  就绪(Runnable)：当调用线程对象的start()方法，线程就进入就绪状态，但是此刻线程调度还没把该线程设置为当前线程，就是没获得CPU使用权。   如果线程运行后，从等待或者睡眠中回来之后，也会进入就绪状态
  	注意:有些文档把就绪和运行两种状态统一称为 “运行中”
  
  运行(Running)
  	程序将处于就绪状态的线程设置为当前线程，即获得CPU使用权，这个时候线程进入运行状态，开始运行run里面的逻辑
  
  阻塞(Blocked)
  	等待阻塞：进入该状态的线程需要等待其他线程作出一定动作(通知或中断)，这种状态的话CPU不会分配过来，他们需要被唤醒，可能也会无限等待下去。比如调用wait(状态就会变成WAITING状态)，也可能通过调用sleep(状态就会变成TIMED_WAITING), join或者发出IO请求，阻塞结束后线程重新进入就绪状态
  	
  	同步阻塞：线程在获取synchronized同步锁失败，即锁被其他线程占用，它就会进入同步阻塞状态
  	
  	备注：相关资料会用细分下面的状态
  		等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。
          超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回
  	
  
  死亡(TERMINATED):一个线程run方法执行结束，该线程就死亡了，不能进入就绪状态
  ```

 

 

 

 

 

 

 

#### 第6集 新版Java线程的常见方法你知道多少？

**简介：线程有几种状态,他们转化关系是怎样的**

- 考点：常见线程的api操作是否熟悉

- 难度：【**】

- 是否了解多线程开发里面常用的方法，sleep/yield/join wait/notify/notifyAll, 分别解释下

  ```
  sleep
  	属于线程Thread的方法
  	让线程暂缓执行，等待预计时间之后再恢复
  	交出CPU使用权，不会释放锁
  	进入阻塞状态TIME_WAITGING，睡眠结束变为就绪Runnable
  	
  yield
  	属于线程Thread的方法
  	t1/t2/t3
  	暂停当前线程的对象，去执行其他线程
  	交出CPU使用权，不会释放锁，和sleep类似
  	作用：让相同优先级的线程轮流执行，但是不保证一定轮流
  	注意：不会让线程进入阻塞状态，直接变为就绪Runnable，只需要重新获得CPU使用权
  	
  	
  join  
  	属于线程Thread的方法
  	在主线程上运行调用该方法，会让主线程休眠，不会释放已经持有的对象锁
  	让调用join方法的线程先执行完毕，在执行其他线程
  	类似让救护车警车优先通过
  	
  wait
  	属于Object的方法
  	当前线程调用对象的wait方法，会释放锁，进入线程的等待队列
  	需要依靠notify或者notifyAll唤醒，或者wait(timeout)时间自动唤醒
  	
  notify
  	属于Object的方法
  	唤醒在对象监视器上等待的单个线程，选择是任意的
  	
  notifyAll
  	属于Object的方法
  	唤醒在对象监视器上等待的全部线程
  	
  	
  ```

   

 

 

#### 第7集 新版Java线程的状态转换流程图你会画不

**简介：线程有几种状态和API，画出转换流程图**

- 考点：常见线程状态和API结合考查

- 难度：【** **】

- 看来挺熟悉多线程的，那你画下线程的状态转换图和这些转换过程常用的api也标记下

  ![image-20200203175236272](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC6%E7%AB%A0/%E7%AC%AC7%E9%9B%86/image-20200203175236272.png)

#### 第8集 新版Java并发编程核心知识点掌握多少《一》

**简介：并发编程常见知识点考查**

- 考点：并发编程常见知识点考查

- 难度：【***】

- 平时业务代码里面使用过多线程吗，能举例几个多线程的业务场景吗？

  ```
  异步任务：用户注册、记录日志
  定时任务：定期备份日志、备份数据库
  分布式计算：Hadoop处理任务mapreduce，master-wark(单机单进程)
  服务器编程：Socket网络编程，一个连接一个线程
  ```

   

- 能举几个不是线程安全的数据结构吗？

  ```
  HashMap、ArrayList、LinkedList
  ```

   

- 在Java中可以有哪些方法来保证线程安全

  ```
  加锁,比如synchronize/ReentrantLock
  使用volatile声明变量，轻量级同步，不能保证原子性(需要解释)
  使用线程安全类(原子类AtomicXXX，并发容器，同步容器 CopyOnWriteArrayList/ConcurrentHashMap等
  ThreadLocal本地私有变量/信号量Semaphore等
  ```

   

 

 

 

 

 

#### 第9集 新版Java并发编程核心知识点volatile掌握多少 《二》

**简介：并发编程常见知识点考查：volatile**

- 考点：并发编程常见知识点考查

- 难度：【***】

- 了解volatile关键字不？能否解释下，然后这和synchronized有什么大的区别

  ```
  volatile是轻量级的synchronized，保证了共享变量的可见性，被volatile关键字修饰的变量，如果值发生了变化，其他线程立刻可见，避免出现脏读现象
  
  volatile：保证可见性，但是不能保证原子性
  synchronized：保证可见性，也保证原子性
  
  使用场景
  1、不能修饰写入操作依赖当前值的变量，比如num++、num=num+1,不是原子操作，肉眼看起来是，但是JVM字节码层面不止一步
  
  2、由于禁止了指令重排，所以JVM相关的优化没了，效率会偏弱
  ```

 

 

- 为什么会出现脏读？

  ```
  JAVA内存模型简称 JMM
  JMM规定所有的变量存在在主内存，每个线程有自己的工作内存,线程对变量的操作都在工作内存中进行，不能直接对主内存就行操作
  
  使用volatile修饰变量
  每次读取前必须从主内存属性最新的值
  每次写入需要立刻写到主内存中
  
  volatile关键字修修饰的变量随时看到的自己的最新值，假如线程1对变量v进行修改，那么线程2是可以马上看见
  ```

  ![image-20200205223949174](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC6%E7%AB%A0/%E7%AC%AC9%E9%9B%86/image-20200205223949174.png)

 

 

 

 

#### 第10集 新版Java并发编程 指令重排/happens-before 掌握多少《三》

**简介：并发编程常见知识点考查：指令重排、happens-before**

- 考点：并发编程常见知识点考查

- 难度：【***】

- 你说volatile可以避免指令重排，能否解释下什么是指令重排

  ```
  指令重排序分两类 编译器重排序和运行时重排序
  
  JVM在编译java代码或者CPU执行JVM字节码时，对现有的指令进行重新排序，主要目的是优化运行效率(不改变程序结果的前提)
  
  int a = 3 //1
  int b = 4 //2
  int c =5 //3 
  int h = a*b*c //4
  
  定义顺序 1,2,3,4
  计算顺序  1,3,2,4 和 2,1,3,4 结果都是一样
  
  
  虽然指令重排序可以提高执行效率，但是多线程上可能会影响结果，有什么解决办法？
  解决办法：内存屏障
  解释：内存屏障是屏障指令，使CPU对屏障指令之前和之后的内存操作执行结果的一种约束
  ```

   

 

- 知道 happens-before吗，能否简单解释下？

  ```
  先行发生原则，volatile的内存可见性就提现了该原则之一
  
  
  例子：
  //线程A操作
  int k = 1;
  
  //线程B操作
  int j = k;
  
  //线程C操作
  int k = 2
  
  分析：
  假设线程A中的操作“k=1”先行发生于线程B的操作“j=k”，那确定在线程B的操作执行后，变量j的值一定等于1，依据有两个：一是先行发生原则，“k=1”的结果可以被观察到；二是第三者线程C还没出现，线程A操作结束之后没有其他线程会修改变量k的值。
  
  但是考虑线程C出现了，保持线程A和线程B之间的先行发生关系，线程C出现在线程A和线程B的操作之间，但是线程C与线程B没有先行发生关系，那j的值会是多少？答案是1和2都有可能，因为线程C对变量k的影响可能会被线程B观察到，也可能不会，所以线程B就存在读取到不符合预期数据的风险，不具备多线程安全性
  
  
  八大原则(对这个不理解，一定要去补充相关博文知识)
  1、程序次序规则
  2、管程锁定规则
  3、volatile变量规则
  4、线程启动规则
  5、线程中断规则
  6、线程终止规则
  7、对象终结规则
  8、传递性
  ```

   

   

   

 

 

 

**![logo](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/image/logo.png) 愿景："让编程不再难学，让技术与生活更加有趣"**

**更多高级架构课程请访问 xdclass.net**

### 第七章 攻克必考知识点 并发编程进阶系列

 

#### 第1集 并发编程三要素你是否知道，解释+例子

**简介: 常见的并发编程三要素**

- 考点：考查是否知道并发编程3要素

- 难度：【 ** **】

- 并发编程三要素是否知道，能否分别解释下，举个简单的例子

  ```
  原子性:一个不可再被分割的颗粒，原子性指的是一个或多个操作要么全部执行成功要么全部执行失败，期间不能被中断，也不存在上下文切换，线程切换会带来原子性的问题
  
  int num = 1; // 原子操作
  num++; // 非原子操作，从主内存读取num到线程工作内存，进行 +1，再把num写到主内存, 除非用原子类，即java.util.concurrent.atomic里的原子变量类
  
  解决办法是可以用synchronized 或 Lock(比如ReentrantLock) 来把这个多步操作“变成”原子操作，但是volatile，前面有说到不能修饰有依赖值的情况
  
  public class XdTest {
      private int num = 0;
      
      //使用lock，每个对象都是有锁，只有获得这个锁才可以进行对应的操作
      Lock lock = new ReentrantLock();
      public  void add1(){
          lock.lock();
          try {
              num++;
          }finally {
              lock.unlock();
          }
      }
      
      //使用synchronized，和上述是一个操作，这个是保证方法被锁住而已，上述的是代码块被锁住
      public synchronized void add2(){
          num++;
      }
  }
  解决核心思想：把一个方法或者代码块看做一个整体，保证是一个不可分割的整体
  
  
  
  
  ========================================
  有序性: 程序执行的顺序按照代码的先后顺序执行，因为处理器可能会对指令进行重排序
  JVM在编译java代码或者CPU执行JVM字节码时，对现有的指令进行重新排序，主要目的是优化运行效率(不改变程序结果的前提)
  int a = 3 //1
  int b = 4 //2
  int c =5 //3 
  int h = a*b*c //4
  
  上面的例子 执行顺序1,2,3,4 和 2,1,3,4 结果都是一样，指令重排序可以提高执行效率，但是多线程上可能会影响结果
  
  假如下面的场景，正常是顺序处理
  //线程1
  before();//处理初始化工作，处理完成后才可以正式运行下面的run方法
  flag = true; //标记资源处理好了，如果资源没处理好，此时程序就可能出现问题
  //线程2
  while(flag){
      run(); //核心业务代码
  }
  
  指令重排序后，导致顺序换了，程序出现问题，且难排查
  
  //线程1
  flag = true; //标记资源处理好了，如果资源没处理好，此时程序就可能出现问题
  //线程2
  while(flag){
      run(); //核心业务代码
  }
  before();//处理初始化工作，处理完成后才可以正式运行下面的run方法
  
  
  
  ========================================
  可见性: 一个线程A对共享变量的修改,另一个线程B能够立刻看到
  // 线程 A 执行
  int num = 0;
  // 线程 A 执行
  num++;
  // 线程 B 执行
  System.out.print("num的值：" + num);
  
  线程A执行 i++ 后再执行线程 B，线程 B可能有2个结果，可能是0和1。
  
  因为 i++ 在线程A中执行运算，并没有立刻更新到主内存当中，而线程B就去主内存当中读取并打印，此时打印的就是0；也可能线程A执行完成更新到主内存了,线程B的值是1。
  所以需要保证线程的可见性
  synchronized、lock和volatile能够保证线程可见性
  ```

 

 

 

 

 

 

#### 第2集 常见进程/线程调度算法你是否知道

**简介: 常见的进程、线程间调度算法**

- 考点：考查是否知道常见进程和线程间的调度算法

- 难度：【 ** **】

- 说下你知道的调度算法，比如进程间的调度；

  ![image-20200206155451336](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC7%E7%AB%A0/%E7%AC%AC2%E9%9B%86/image-20200206155451336.png)

  ```
  先来先服务调度算法：
  	按照作业/进程到达的先后顺序进行调度 ，即：优先考虑在系统中等待时间最长的作业
  	排在长进程后的短进程的等待时间长，不利于短作业/进程
  
  短作业优先调度算法：
  	短进程/作业（要求服务时间最短）在实际情况中占有很大比例，为了使得它们优先执行
  	对长作业不友好
  
  高响应比优先调度算法: 
  	在每次调度时，先计算各个作业的优先权：优先权=响应比=（等待时间+要求服务时间）/要求服务时间,
  	因为等待时间与服务时间之和就是系统对该作业的响应时间，所以 优先权=响应比=响应时间/要求服务时间，选	   择优先权高的进行服务需要计算优先权信息，增加了系统的开销
  	
  
  时间片轮转调度算法:
  	轮流的为各个进程服务，让每个进程在一定时间间隔内都可以得到响应
  	由于高频率的进程切换，会增加了开销，且不区分任务的紧急程度
  
  
  优先级调度算法:
  	根据任务的紧急程度进行调度，高优先级的先处理，低优先级的慢处理
  	如果高优先级任务很多且持续产生，那低优先级的就可能很慢才被处理
  ```

![image-20200206152406710](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC7%E7%AB%A0/%E7%AC%AC2%E9%9B%86/image-20200206152406710.png)

 

- 常见的线程间的调度算法是怎样的，java是哪种

  ```
  线程调度是指系统为线程分配CPU使用权的过程，主要分两种
  
  协同式线程调度(分时调度模式)：线程执行时间由线程本身来控制，线程把自己的工作执行完之后，要主动通知系统切换到另外一个线程上。最大好处是实现简单，且切换操作对线程自己是可知的，没啥线程同步问题。坏处是线程执行时间不可控制，如果一个线程有问题，可能一直阻塞在那里
  
  
  抢占式线程调度：每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定（Java中，Thread.yield()可以让出执行时间，但无法获取执行时间）。线程执行时间系统可控，也不会有一个线程导致整个进程阻塞
  
  
  Java线程调度就是抢占式调度,优先让可运行池中优先级高的线程占用CPU,如果可运行池中的线程优先级相同,那就随机选择一个线程
  
  所以我们如果希望某些线程多分配一些时间，给一些线程少分配一些时间，可以通过设置线程优先级来完成。
  JAVA的线程的优先级，以1到10的整数指定。当多个线程可以运行时，VM一般会运行最高优先级的线程（Thread.MIN_PRIORITY至Thread.MAX_PRIORITY）
  
  在两线程同时处于就绪runnable状态时，优先级越高的线程越容易被系统选择执行。但是优先级并不是100%可以获得，只不过是机会更大而已。
  
  有人会说，wait,notify不就是线程本身控制吗？
  其实不是，wait是可以让出执行时间，notify后无法获取执行时间，随机等待队列里面获取而已
  ```

 

 

 

 

 

 

#### 第3集 java多线程里面常用的锁找你知道多少《上》

- 考点：考查对常见的锁是否掌握

- 难度：【 ** **】

- 你日常开发里面用过java里面有哪些锁？分别解释下

  ```
  悲观锁：当线程去操作数据的时候，总认为别的线程会去修改数据，所以它每次拿数据的时候都会上锁，别的线程去拿数据的时候就会阻塞，比如synchronized
  乐观锁：每次去拿数据的时候都认为别人不会修改，更新的时候会判断是别人是否回去更新数据，通过版本来判断，如果数据被修改了就拒绝更新，比如CAS是乐观锁，但严格来说并不是锁，通过原子性来保证数据的同步，比如说数据库的乐观锁，通过版本控制来实现，CAS不会保证线程同步，乐观的认为在数据更新期间没有其他线程影响
  小结：悲观锁适合写操作多的场景，乐观锁适合读操作多的场景，乐观锁的吞吐量会比悲观锁多
  
  
  公平锁：指多个线程按照申请锁的顺序来获取锁，简单来说 如果一个线程组里，能保证每个线程都能拿到锁 比如ReentrantLock(底层是同步队列FIFO:First Input First Output来实现)
  非公平锁：获取锁的方式是随机获取的，保证不了每个线程都能拿到锁，也就是存在有线程饿死,一直拿不到锁，比如synchronized、ReentrantLock
  小结：非公平锁性能高于公平锁，更能重复利用CPU的时间
  
  
  可重入锁：也叫递归锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁
  不可重入锁：若当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到被阻塞
  小结：可重入锁能一定程度的避免死锁 synchronized、ReentrantLock 重入锁
  
    	private void meathA(){
              //获取锁 TODO
          meathB();
      }
  
      private void meathB(){
              //获取锁 TODO
              //其他操作
      }
  
  
  
  自旋锁：一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环,任何时刻最多只能有一个执行单元获得锁.
  小结：不会发生线程状态的切换，一直处于用户态，减少了线程上下文切换的消耗，缺点是循环会消耗CPU
  常见的自旋锁：TicketLock,CLHLock,MSCLock
  ```

![image-20200209111713894](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC7%E7%AB%A0/%E7%AC%AC3%E9%9B%86/image-20200209111713894.png)

 

 

 

 

 

 

#### 第4集 java多线程里面常用的锁找你知道多少《下》

- 考点：考查对常见的锁是否掌握
- 难度：【 ** **】
- 你日常开发里面用过java里面有哪些锁？分别解释下

```
共享锁：也叫S锁/读锁，能查看但无法修改和删除的一种数据锁，加锁后其它用户可以并发读取、查询数据，但不能修改，增加，删除数据，该锁可被多个线程所持有，用于资源数据共享

互斥锁：也叫X锁/排它锁/写锁/独占锁/独享锁/ 该锁每一次只能被一个线程所持有,加锁后任何线程试图再次加锁的线程会被阻塞，直到当前线程解锁。例子：如果 线程A 对 data1 加上排他锁后，则其他线程不能再对 data1 加任何类型的锁,获得互斥锁的线程即能读数据又能修改数据

死锁：两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法让程序进行下去

下面三种是Jvm为了提高锁的获取与释放效率而做的优化 针对Synchronized的锁升级，锁的状态是通过对象监视器在对象头中的字段来表明，是不可逆的过程，
偏向锁：一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，获取锁的代价更低，
轻量级锁：当锁是偏向锁的时候，被其他线程访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，但不会阻塞，且性能会高点
重量级锁：当锁为轻量级锁的时候，其他线程虽然是自旋，但自旋不会一直循环下去，当自旋一定次数的时候且还没有获取到锁，就会进入阻塞，该锁升级为重量级锁，重量级锁会让其他申请的线程进入阻塞，性能也会降低

分段锁、行锁、表锁
```

![image-20200209111647482](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC7%E7%AB%A0/%E7%AC%AC4%E9%9B%86/image-20200209111647482.png)

 

 

 

 

 

 

 

#### 第5集 上机实战之多线程里面的死锁，写一个例子并解决死锁

- 考点：考查对常见的死锁是否掌握
- 难度：【 ** ** * 】
- 上机实战：写个多线程死锁的例子

```
线程在获得了锁A并且没有释放的情况下去申请锁B，
这时另一个线程已经获得了锁B，在释放锁B之前又要先获得锁A
因此闭环发生，陷入死锁循环
/**
 * 小滴课堂
 * 面试专题第一季
 *
 */
public class DeadLockDemo {

    private static String locka = "locka";

    private static String lockb = "lockb";

    public void methodA(){

        synchronized (locka){
            System.out.println("我是A方法中获得了锁A "+Thread.currentThread().getName() );

            //让出CPU执行权，不释放锁
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            synchronized(lockb){
                System.out.println("我是A方法中获得了锁B "+Thread.currentThread().getName() );
            }
        }

    }


    public void methodB(){
        synchronized (lockb){
            System.out.println("我是B方法中获得了锁B "+Thread.currentThread().getName() );

            //让出CPU执行权，不释放锁
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            synchronized(locka){
                System.out.println("我是B方法中获得了锁A "+Thread.currentThread().getName() );
            }
        }

    }


    public static void main(String [] args){

        System.out.println("主线程运行开始运行："+Thread.currentThread().getName());

        DeadLockDemo deadLockDemo = new DeadLockDemo();

        new Thread(()->{
            deadLockDemo.methodA();
        }).start();

        new Thread(()->{
            deadLockDemo.methodB();
        }).start();

        System.out.println("主线程运行结束："+Thread.currentThread().getName());

    }

}
```

 

- 线上经常会产生诡异的情况，有可能是死锁，且难排查！！！

  ```
  死锁的4个必要条件
  
  互斥条件：资源不能共享，只能由一个线程使用
  请求与保持条件：线程已经获得一些资源，但因请求其他资源发生阻塞，对已经获得的资源保持不释放
  不可抢占：有些资源是不可强占的，当某个线程获得这个资源后，系统不能强行回收，只能由线程使用完自己释放
  循环等待条件：多个线程形成环形链，每个都占用对方申请的下个资源
  
  只要发生死锁，上面的条件都成立；只要一个不满足，就不会发生死锁
  ```

 

- 那上面的例子怎么解决死锁，优化下代码

```
常见的解决办法：
	调整申请锁的范围
	调整申请锁的顺序

/**
 * 小滴课堂 面试专题第一季
 * 解决 死锁，通过调整锁的范围
 */
public class FixDeadLockDemo {

    private static String locka = "locka";

    private static String lockb = "lockb";

    public void methodA(){

        synchronized (locka){
            System.out.println("我是A方法中获得了锁A "+Thread.currentThread().getName() );

            //让出CPU执行权，不释放锁
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }

        synchronized(lockb){
            System.out.println("我是A方法中获得了锁B "+Thread.currentThread().getName() );
        }
    }


    public void methodB(){
        synchronized (lockb){
            System.out.println("我是B方法中获得了锁B "+Thread.currentThread().getName() );

            //让出CPU执行权，不释放锁
            try {
                Thread.sleep(2000);

            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }

        synchronized(locka){
            System.out.println("我是B方法中获得了锁A "+Thread.currentThread().getName() );
        }
    }


    public static void main(String [] args){

        System.out.println("主线程运行开始运行："+Thread.currentThread().getName());

        FixDeadLockDemo deadLockDemo = new FixDeadLockDemo();


        for(int i=0; i<10;i++){
            new Thread(()->{
                deadLockDemo.methodA();
            }).start();

            new Thread(()->{
                deadLockDemo.methodB();
            }).start();
        }

        System.out.println("主线程运行结束："+Thread.currentThread().getName());

    }

}
```

 

 

 

#### 第6集 上机实战之多线程里面的不可重入锁设计

- 考点：考查对常见的不可重入锁是否掌握
- 难度：【 ** ** 】
- 上机实战：设计一个简单的不可重入锁

```
不可重入锁：若当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到被阻塞

  	private void methodA(){
            //获取锁 TODO
        methodB();
    }

    private void methodB(){
            //获取锁 TODO
            //其他操作
    }
/**
 * 小滴课堂:二当家小D
 *
 * 不可重入锁 简单例子
 *
 *  不可重入锁：若当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到被阻塞
 */
public class UnreentrantLock {

    private boolean isLocked = false;

    public synchronized void lock() throws InterruptedException {

        System.out.println("进入lock加锁 "+Thread.currentThread().getName());

        //判断是否已经被锁，如果被锁则当前请求的线程进行等待
        while (isLocked){
            System.out.println("进入wait等待 "+Thread.currentThread().getName());
            wait();
        }
        //进行加锁
        isLocked = true;
    }
    public synchronized void unlock(){
        System.out.println("进入unlock解锁 "+Thread.currentThread().getName());
        isLocked = false;
        //唤醒对象锁池里面的一个线程
        notify();
    }
}



public class Main {
    private UnreentrantLock unreentrantLock = new UnreentrantLock();
    //加锁建议在try里面，解锁建议在finally
    public void  methodA(){
        try {
            unreentrantLock.lock();
            System.out.println("methodA方法被调用");
            methodB();
        }catch (InterruptedException e){
            e.fillInStackTrace();
        } finally {
            unreentrantLock.unlock();
        }
    }

    public void methodB(){
        try {
            unreentrantLock.lock();
            System.out.println("methodB方法被调用");
        }catch (InterruptedException e){
            e.fillInStackTrace();
        } finally {
            unreentrantLock.unlock();
        }
    }
    public static void main(String [] args){
        //演示的是同个线程
        new Main().methodA();
    }
}

//同一个线程，重复获取锁失败，形成死锁，这个就是不可重入锁
```

 

 

#### 第7集 上机实战之多线程里面的可重入锁设计

- 考点：考查对常见的重入锁是否掌握
- 难度：【 ** ** * 】
- 上机实战：设计一个简单的可重入锁

```
可重入锁：也叫递归锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁


/**
 * 小滴课堂:二当家小D
 *
 * 可重入锁 简单例子
 *
 *  不可重入锁：也叫递归锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁
 */
public class ReentrantLock {

    private boolean isLocked = false;

    //用于记录是不是重入的线程
    private Thread lockedOwner = null;

    //累计加锁次数，加锁一次累加1，解锁一次减少1
    private int lockedCount = 0;

    public synchronized void lock() throws InterruptedException {

        System.out.println("进入lock加锁 "+Thread.currentThread().getName());

        Thread thread = Thread.currentThread();

        //判断是否是同个线程获取锁, 引用地址的比较
        while (isLocked && lockedOwner != thread ){
            System.out.println("进入wait等待 "+Thread.currentThread().getName());
            System.out.println("当前锁状态 isLocked = "+isLocked);
            System.out.println("当前count数量 lockedCount =  "+lockedCount);
            wait();
        }

        //进行加锁
        isLocked = true;
        lockedOwner = thread;
        lockedCount++;
    }
    public synchronized void unlock(){
        System.out.println("进入unlock解锁 "+Thread.currentThread().getName());

        Thread thread = Thread.currentThread();

        //线程A加的锁，只能由线程A解锁，其他线程B不能解锁
        if(thread == this.lockedOwner){
            lockedCount--;
            if(lockedCount == 0){
                isLocked = false;
                lockedOwner = null;
                //唤醒对象锁池里面的一个线程
                notify();
            }
        }
    }
}




public class Main {
    //private UnreentrantLock unreentrantLock = new UnreentrantLock();
    private ReentrantLock reentrantLock = new ReentrantLock();

    //加锁建议在try里面，解锁建议在finally
    public void  methodA(){

        try {
            reentrantLock.lock();
            System.out.println("methodA方法被调用");
            methodB();

        }catch (InterruptedException e){
            e.fillInStackTrace();

        } finally {
            reentrantLock.unlock();
        }

    }

    public void methodB(){

        try {
            reentrantLock.lock();
            System.out.println("methodB方法被调用");

        }catch (InterruptedException e){
            e.fillInStackTrace();

        } finally {
            reentrantLock.unlock();
        }
    }

    public static void main(String [] args){
        for(int i=0 ;i<10;i++){
            //演示的是同个线程
            new Main().methodA();
        }
    }
}
```

 

 

 

 

 

#### 第8集 多线程的synchronized了解不，新版JDK里面优化点

- 考点：考查对常见的synchronized是否掌握，新版JDK6里面优化了什么
- 难度：【 ** **】
- 对synchronized了解不，能否介绍下你对synchronized的理解

```
synchronized是解决线程安全的问题，常用在 同步普通方法、静态方法、代码块 中

非公平、可重入

每个对象有一个锁和一个等待队列，锁只能被一个线程持有，其他需要锁的线程需要阻塞等待。锁被释放后，对象会从队列中取出一个并唤醒，唤醒哪个线程是不确定的，不保证公平性

两种形式：
方法：生成的字节码文件中会多一个 ACC_SYNCHRONIZED 标志位，当一个线程访问方法时，会去检查是否存在ACC_SYNCHRONIZED标识，如果存在，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象，也叫隐式同步

代码块：加了 synchronized 关键字的代码段，生成的字节码文件会多出 monitorenter 和 monitorexit 两条指令，每个monitor维护着一个记录着拥有次数的计数器, 未被拥有的monitor的该计数器为0，当一个线程获执行monitorenter后，该计数器自增1;当同一个线程执行monitorexit指令的时候，计数器再自减1。当计数器为0的时候,monitor将被释放.也叫显式同步

两种本质上没有区别，底层都是通过monitor来实现同步, 只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成
查看字节码 
javac XXX.java
javap -v XXX.class
```

- 同步方法字节码

  ![image-20200210184107485](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC7%E7%AB%A0/%E7%AC%AC8%E9%9B%86/%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E5%AD%97%E8%8A%82%E7%A0%81.png)

- 同步代码块字节码

![image-20200210183949717](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC7%E7%AB%A0/%E7%AC%AC8%E9%9B%86/%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E5%AD%97%E8%8A%82%E7%A0%81.png)

- jdk1.6后进行了优化，你知道哪些大的变化

```
有得到锁的资源进入Block状态,涉及到操作系统用户模式和内核模式的切换，代价比较高
jdk6进行了优化，增加了从偏向锁到轻量级锁再到重量级锁的过渡，但是在最终转变为重量级锁之后，性能仍然较低
```

![image-20200210183813283](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC7%E7%AB%A0/%E7%AC%AC8%E9%9B%86/synchronized-img.png)

 

 

 

 

 

 

 

 

#### 第9集 高性能的Compare and Swap 你知道多少

**简介：并发编程面试核心点CAS考查**

- 考点：考查对常见的CAS是否掌握
- 难度：【 ** ** 】

- 了解CAS不，能否解释下什么是CAS

  ```
  全称是Compare And Swap，即比较再交换，是实现并发应用到的一种技术
  底层通过Unsafe类实现原子性操作操作包含三个操作数 —— 内存地址（V）、预期原值（A）和新值(B)。 
  如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 ，若果在第一轮循环中，a线程获取地址里面的值被b线程修改了，那么a线程需要自旋，到下次循环才有可能机会执行。
  
  CAS这个是属于乐观锁，性能较悲观锁有很大的提高
  AtomicXXX 等原子类底层就是CAS实现，一定程度比synchonized好，因为后者是悲观锁
  ```

![image-20200212185212328](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC7%E7%AB%A0/%E7%AC%AC9%E9%9B%86/image-20200212185212328.png)

 

 

 

 

 

 

#### 第10集 CAS性能虽好, 但存在的ABA问题你知道不？

**简介：并发编程面试核心点CAS常见存在的问题考查**

- 考点：考查对CAS常见的问题是否掌握
- 难度：【 ** ** 】

- CAS会存在什么比较严重的问题？

  ```
  1、自旋时间长CPU利用率增加，CAS里面是一个循环判断的过程，如果线程一直没有获取到状态，cpu资源会一直被占用
  
  2、存在ABA问题 
  ```

 

- 能否解释下什么是ABA问题，怎么避免这个问题呢？

  ```
  如果一个变量V初次读取是A值，并且在准备赋值的时候也是A值，那就能说明A值没有被修改过吗？其实是不能的，因为变量V可能被其他线程改回A值，结果就是会导致CAS操作误认为从来没被修改过，从而赋值给V
  
  给变量加一个版本号即可，在比较的时候不仅要比较当前变量的值 还需要比较当前变量的版本号。
  在java5中，已经提供了AtomicStampedReference来解决问题，检查当前引用是否等于预期引用，其次检查当前标志是否等于预期标志，如果都相等就会以原子的方式将引用和标志都设置为新值
  ```

![image-20200212185349818](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC7%E7%AB%A0/%E7%AC%AC10%E9%9B%86/image-20200212185349818.png)

 

 

 

 

 

 

 

**![logo](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/image/logo.png) 愿景："让编程不再难学，让技术与生活更加有趣"**

**更多高级架构课程请访问 xdclass.net**

### 第八章 手把手剖析并发底层原理和最佳实践

 

#### 第1集 并发编程核心底层AQS你知道不

**简介: 常见的并发编程AQS考查**

- 考点：考查是否知道并发编程AQS

- 难度：【 ** ** * 】

- 知道AQS吗？能否介绍下，它的核心思想是什么

  ```
  AQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包下面。它是一个Java提高的底层同步工具类，比如CountDownLatch、ReentrantLock，Semaphore，ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的
  
  只要搞懂了AQS，那么J.U.C中绝大部分的api都能轻松掌握
  
  简单来说：是用一个int类型的变量表示同步状态，并提供了一系列的CAS操作来管理这个同步状态对象
  一个是 state（用于计数器，类似gc的回收计数器）
  一个是线程标记（当前线程是谁加锁的），
  一个是阻塞队列（用于存放其他未拿到锁的线程)
  
  
  例子：线程A调用了lock()方法，通过CAS将state赋值为1，然后将该锁标记为线程A加锁。如果线程A还未释放锁时，线程B来请求，会查询锁标记的状态，因为当前的锁标记为 线程A，线程B未能匹配上，所以线程B会加入阻塞队列，直到线程A触发了 unlock() 方法，这时线程B才有机会去拿到锁，但是不一定肯定拿到
  ```

  ```
  acquire(int arg) 源码讲解，好比加锁lock操作
      tryAcquire()尝试直接去获取资源，如果成功则直接返回,AQS里面未实现但没有定义成abstract，因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared，类似设计模式里面的适配器模式
  
      addWaiter() 根据不同模式将线程加入等待队列的尾部，有Node.EXCLUSIVE互斥模式、Node.SHARED共享模式；如果队列不为空，则以通过compareAndSetTail方法以CAS将当前线程节点加入到等待队列的末尾。否则通过enq(node)方法初始化一个等待队列
  
      acquireQueued()使线程在等待队列中获取资源，一直获取到资源后才返回,如果在等待过程中被中断，则返回true，否则返回false
  
  release(int arg)源码讲解 好比解锁unlock
  	独占模式下线程释放指定量的资源，里面是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了；在自义定同步器在实现时，如果已经彻底释放资源(state=0)，要返回true，否则返回false
      unparkSuccessor方法用于唤醒等待队列中下一个线程
  ```

  ![image-20200214151433962](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC8%E7%AB%A0/%E7%AC%AC1%E9%9B%86/image-20200214151433962.png)

- 你知道的AQS有几种同步方式，实现同步器一般要覆盖哪些方法

  ```
  独占式: 比如ReentrantLock
  
  共享式：比如Semaphore
  
  存在组合：组合式的如ReentrantReadWriteLock，AQS为使用提供了底层支撑，使用者可以自由组装实现
  
  
  1. boolean tryAcquire(int arg) 
  2. boolean tryRelease(int arg) 
  3. int tryAcquireShared(int arg) 
  4. boolean tryReleaseShared(int arg) 
  5. boolean isHeldExclusively()
  
  不需要全部实现，根据获取的锁的种类可以选择实现不同的方法，比如
  实现支持独占锁的同步器应该实现tryAcquire、 tryRelease、isHeldExclusively
  实现支持共享获取的同步器应该实现tryAcquireShared、tryReleaseShared、isHeldExclusively
  ```

  

   

- 注意：线程获取锁成功后直接返回，不会进入等待队列里面，只有失败的时候才会

  ```
  //线程获取锁成功后 直接返回，不会进入等待队列里面，只有失败的时候才会
  public final void acquire(int arg) {
  if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
  　　selfInterrupt();
  }
  
  =========
  //获取失败则将当前线程封装为Node.EXCLUSIVE的Node节点插入AQS阻塞队列的尾部
   final boolean acquireQueued(final Node node, int arg) {
          boolean failed = true;
          try {
              boolean interrupted = false;
              for (;;) {
                  final Node p = node.predecessor();
                  if (p == head && tryAcquire(arg)) {
                      setHead(node);
                      p.next = null; // help GC
                      failed = false;
                      return interrupted;
                  }
                  if (shouldParkAfterFailedAcquire(p, node) &&
                      parkAndCheckInterrupt())
                      interrupted = true;
              }
          } finally {
              if (failed)
                  cancelAcquire(node);
          }
      }
  ==================
  //调用LockSupport.park(this)方式阻塞自己
   private final boolean parkAndCheckInterrupt() {
          LockSupport.park(this);
          return Thread.interrupted();
   }
  ```

   

 

 

 

#### 第2集 源码剖析并发编程ReentrantLock实现原理

**简介: 源码解析ReentrantLock实现原理**

- 考点：考查是否知道ReentrantLock底层实现 (如果对上集AQS不熟悉，可以看这集后再去回顾AQS)
- 难度：【 ** ** * 】
- java里面的公平锁和非公平锁你知道多少，有没看过ReentrantLock源码？

![image-20200214165922487](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC8%E7%AB%A0/%E7%AC%AC2%E9%9B%86/image-20200214165922487.png)

- 公平锁和非公平锁核心区别

![image-20200214170916300](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC8%E7%AB%A0/%E7%AC%AC2%E9%9B%86/image-20200214170916300.png)

 

 

 

 

 

 

 

 

#### 第3集 你可以说清ReentrantLock和synchronized的差别不

**简介: 源码解析ReentrantLock实现原理**

- 考点：考查ReentrantLock和synchronized的掌握情况
- 难度：【 ** ** 】

- ReentrantLock和synchronized使用的场景是什么，实现机制有什么不同

  ```
  ReentrantLock和synchronized都是独占锁
  
  synchronized：
  	1、是悲观锁会引起其他线程阻塞，java内置关键字，
  	2、无法判断是否获取锁的状态，锁可重入、不可中断、只能是非公平
  	3、加锁解锁的过程是隐式的,用户不用手动操作,优点是操作简单但显得不够灵活
  	4、一般并发场景使用足够、可以放在被递归执行的方法上,且不用担心线程最后能否正确释放锁
  	5、synchronized操作的应该是对象头中mark word，参考原先原理图片
  
  ReentrantLock：
  	1、是个Lock接口的实现类，是悲观锁，
  	2、可以判断是否获取到锁，可重入、可判断、可公平可不公平
  	3、需要手动加锁和解锁,且 解锁的操作尽量要放在finally代码块中,保证线程正确释放锁
  	4、在复杂的并发场景中使用在重入时要却确保重复获取锁的次数必须和重复释放锁的次数一样，否则可能导致		其他线程无法获得该锁。
  	5、创建的时候通过传进参数true创建公平锁,如果传入的是false或没传参数则创建的是非公平锁
  	6、底层不同是AQS的state和FIFO队列来控制加锁
  ```

 

 

 

#### 第4集 读写锁ReentrantReadWriteLock你是否知道

**简介: 讲解ReentrantReadWriteLock读写锁的掌握情况**

- 考点：考查ReentrantReadWriteLock读写锁的掌握情况
- 难度：【 ** ** * 】

- 知道ReentrantReadWriteLock吗？和ReentrantLock有啥不同？

  ![image-20200215105626961](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC8%E7%AB%A0/%E7%AC%AC4%E9%9B%86/image-20200215105626961.png)

  ```
  ReentrantReadWriteLock
  	1、读写锁接口ReadWriteLock接口的一个具体实现，实现了读写锁的分离，
  	2、支持公平和非公平，底层也是基于AQS实现
  	3、允许从写锁降级为读锁
  		流程：先获取写锁，然后获取读锁，最后释放写锁；但不能从读锁升级到写锁
  		
  	4、重入：读锁后还可以获取读锁；获取了写锁之后既可以再次获取写锁又可以获取读锁
  	核心：读锁是共享的，写锁是独占的。 读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，主要是提升了读写的性能
  	
  
  
  ReentrantLock是独占锁且可重入的，相比synchronized而言功能更加丰富也更适合复杂的并发场景，但是也有弊端，假如有两个线程A/B访问数据，加锁是为了防止线程A在写数据， 线程B在读数据造成的数据不一致； 但线程A在读数据，线程C也在读数据，读数据是不会改变数据没有必要加锁，但是还是加锁了，降低了程序的性能，所以就有了ReadWriteLock读写锁接口
  
  
  场景：读多写少，比如设计一个缓存组件 或 提高Collection的并发性
  class CachedData {
   *   Object data;
   *   volatile boolean cacheValid;
   *   final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
   *
   *   void processCachedData() {
   *     rwl.readLock().lock();
   *     if (!cacheValid) {
   *       // Must release read lock before acquiring write lock
   *       rwl.readLock().unlock();
   *       rwl.writeLock().lock();
   *       try {
   *         // Recheck state because another thread might have
   *         // acquired write lock and changed state before we did.
   *         if (!cacheValid) {
   *           data = ...
   *           cacheValid = true;
   *         }
   *         // Downgrade by acquiring read lock before releasing write lock
   *         rwl.readLock().lock();
   *       } finally {
   *         rwl.writeLock().unlock(); // Unlock write, still hold read
   *       }
   *     }
   *
   *     try {
   *       use(data);
   *     } finally {
   *       rwl.readLock().unlock();
   *     }
   *   }
   * }}
   
   
    class RWDictionary {
   *   private final Map<String, Data> m = new TreeMap<String, Data>();
   *   private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
   *   private final Lock r = rwl.readLock();
   *   private final Lock w = rwl.writeLock();
   *
   *   public Data get(String key) {
   *     r.lock();
   *     try { return m.get(key); }
   *     finally { r.unlock(); }
   *   }
   *   public String[] allKeys() {
   *     r.lock();
   *     try { return m.keySet().toArray(); }
   *     finally { r.unlock(); }
   *   }
   *   public Data put(String key, Data value) {
   *     w.lock();
   *     try { return m.put(key, value); }
   *     finally { w.unlock(); }
   *   }
   *   public void clear() {
   *     w.lock();
   *     try { m.clear(); }
   *     finally { w.unlock(); }
   *   }
   * }}
  ```

 

 

 

 

 

#### 第5集 阻塞队列BlockingQueue是否知道

**简介: 讲解阻塞队列BlockingQueue的掌握情况**

- 考点：考查阻塞队列BlockingQueue的掌握情况

- 难度：【 ** ** 】

- 并发编程里面解决生产消费者模型你知道哪几种方式？

  ```
  核心：要保证生产者不会在缓冲区满时放入数据，消费者也不会在缓冲区空时消耗数据
  
  常用的同步方法是采用信号或加锁机制
  1、wait() / notify()方法
  	
  2、await() / signal()方法
  	用ReentrantLock和Condition实现等待/通知模型
  
  3、Semaphore信号量
  
  4、BlockingQueue阻塞队列
  	ArrayBlockingQueue
  	LinkedBlockingQueue
  		put方法用来向队尾存入元素，如果队列满，则阻塞
  	　　 take方法用来从队首取元素，如果队列为空，则阻塞
  ```

 

 

 

- 你知道阻塞队列BlockingQueue不？介绍下常见的阻塞队列

  ```
  BlockingQueue: j.u.c包下的提供了线程安全的队列访问的接口，并发包下很多高级同步类的实现都是基于阻塞队列实现的
  
  1、当阻塞队列进行插入数据时，如果队列已满，线程将会阻塞等待直到队列非满
  2、从阻塞队列读数据时，如果队列为空，线程将会阻塞等待直到队列里面是非空的时候
  
  常见的阻塞队列
  	ArrayBlockingQueue：
  		基于数组实现的一个阻塞队列，需要指定容量大小，FIFO先进先出顺序
  	
  	LinkedBlockingQueue：
  		基于链表实现的一个阻塞队列，如果不指定容量大小，默认 Integer.MAX_VALUE, FIFO先进先出顺序
  	
  	PriorityBlockingQueue：
  		一个支持优先级的无界阻塞队列，默认情况下元素采用自然顺序升序排序，也可以自定义排序实现 java.lang.Comparable接口
  	
  	DelayQueue：
  		延迟队列，在指定时间才能获取队列元素的功能，队列头元素是最接近过期的元素，里面的对象必须实现 java.util.concurrent.Delayed 接口并实现CompareTo和getDelay方法
  	
  ```

   

 

 

 

#### 第6集 并发队列ConcurrentLinkedQueue是否掌握

**简介: 讲解非阻塞队列ConcurrentLinkedQueue的掌握情况**

- 考点：考查非阻塞队列ConcurrentLinkedQueue的掌握情况

- 难度：【 ** ** 】

- 你知道非阻塞队列ConcurrentLinkedQueue不，它怎么实现线程安全的？

  ```
  线程安全原因：
  ConcurrentLinkedQueue是基于链表实现的无界线程安全队列，采用FIFO进行排序
  保证线程安全的三要素：原子、有序、可见性
  
  1、底层结构是Node，链表头部和尾部节点是head和tail，使用节点变量和内部类属性使用volatile声明保证了有序和可见性
  
  2、插入、移除、更新操作使用CAS无锁操作，保证了原子性
  
  3、假如多线程并发修改导致 CAS 更新失败，采用for循环插入保证更新操作成功
  ```

 

 

 

 

 

 

#### 第7集 说说你认为的并发编程最佳实践

**简介: 并发编程常用的最佳实践**

- 考点：考查是否有用多线程，总结个人的最佳实践

- 难度：【 *** 】

- 平时多线程用的挺多的，写出3条你遵循的多线程最佳实践

  ```
  给不同模块的线程起名称，方便后续排查问题
  
  使用同步代码块或者同步的方法的时候，尽量减小同步范围
  
  多用并发集合少用同步集合
  	支持线程安全
  		同步集合：Hashtable/Vector/同步工具类包装Collections.synXXX
  		并发集合：ConcurrentHashMap、CopyOnWriteArrayList
  
  线上业务需要使用多线程，优先考虑线程池是否更加合适，然后判断哪种线程池比较好，最后才是自己创建单一线程
  ```

   

- 用过线程池不? 有什么好处， java里有哪些是常用的线程池

  ```
  好处：重用存在的线程，减少对象创建销毁的开销，有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞，且可以定时定期执行、单线程、并发数控制，配置任务过多任务后的拒绝策略等功能
  
  类别
  newFixedThreadPool 
  	一个定长线程池，可控制线程最大并发数
  
  newCachedThreadPool
  	一个可缓存线程池
  
  newSingleThreadExecutor
  	一个单线程化的线程池，用唯一的工作线程来执行任务
  
  newScheduledThreadPool
  	一个定长线程池，支持定时/周期性任务执行
  ```

 

 

 

 

 

 

 

#### 第8集 线程池里面的坑你踩过吗？

**简介:常见线程池里面坑是否知道**

- 考点：是否知道线程池里面的坑

- 难度：【 ** ** 】

- 【阿里巴巴编码规范】 线程池不允许使用 Executors 去创建，要通过 ThreadPoolExecutor的方式原因？

  ```
  Executors创建的线程池底层也是调用 ThreadPoolExecutor，只不过使用不同的参数、队列、拒绝策略等,如果使用不当，会造成资源耗尽问题；
  直接使用ThreadPoolExecutor让使用者更加清楚线程池允许规则，常见参数的使用，避免风险
  
  常见的线程池问题：
  newFixedThreadPool和newSingleThreadExecutor: 
  	队列使用LinkedBlockingQueue，队列长度为 Integer.MAX_VALUE，可能造成堆积，导致OOM
  
  newScheduledThreadPool和newCachedThreadPool:
  	线程池里面允许最大的线程数是Integer.MAX_VALUE，可能会创建过多线程，导致OOM
  ```

![image-20200221104045559](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC8%E7%AB%A0/%E7%AC%AC8%E9%9B%86/image-20200221104045559.png)

![image-20200221104151858](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC8%E7%AB%A0/%E7%AC%AC8%E9%9B%86/image-20200221104151858.png)

 

 

 

 

 

 

 

 

 

#### 第9集 ThreadPoolExecutor核心参数是否掌握

**简介: 并发编程里面的ThreadPoolExecutor参数考查**

- 考点：ThreadPoolExecutor常见参数的掌握

- 难度：【 ** ** *】

- ThreadPoolExecutor构造函数里面的参数你是否掌握，能否解释下各个参数的作用

  ```
  public ThreadPoolExecutor(int corePoolSize,
                                int maximumPoolSize,
                                long keepAliveTime,
                                TimeUnit unit,
                                BlockingQueue<Runnable> workQueue,
                                ThreadFactory threadFactory,
                                RejectedExecutionHandler handler)
  ```

  ```
  corePoolSize：核心线程数，线程池也会维护线程的最少数量，默认情况下核心线程会一直存活，即使没有任务也不会受存keepAliveTime控制
   坑：在刚创建线程池时线程不会立即启动，到有任务提交时才开始创建线程并逐步线程数目达到corePoolSize
  
  maximumPoolSize：线程池维护线程的最大数量，超过将被阻塞
   坑：当核心线程满，且阻塞队列也满时，才会判断当前线程数是否小于最大线程数，才决定是否创建新线程
  
  keepAliveTime：非核心线程的闲置超时时间，超过这个时间就会被回收，直到线程数量等于corePoolSize
  
  unit：指定keepAliveTime的单位，如TimeUnit.SECONDS、TimeUnit.MILLISECONDS
  
  workQueue:线程池中的任务队列,常用的是 ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue
  
  
  threadFactory：创建新线程时使用的工厂
  
  handler: RejectedExecutionHandler是一个接口且只有一个方法,线程池中的数量大于maximumPoolSize，对拒绝任务的处理策略，默认有4种策略AbortPolicy、CallerRunsPolicy、DiscardOldestPolicy、DiscardPolicy
  ```

   

 

 

**![logo](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/image/logo.png) 愿景："让编程不再难学，让技术与生活更加有趣"**

**更多高级架构课程请访问 xdclass.net**

### 第九章 带你走进中间件之消息队列面试环节



#### 第1集 你知道主流消息队列和怎么选型吗

**简介：对比当下主流的消息队列和选择问题**

- 考点：是否有了解主流消息队列

- 难度：【 ** *】

- 你用过消息队列，引入队列有啥优缺点，对比其他消息中间产品，选择这款的原因是啥？

  - 优点：解耦系统、异步化、削峰

  - 缺点: 系统可用性降低、复杂度增高、维护成本增高

     

  - 主流消息队列Apache ActiveMQ、Kafka、RabbitMQ、RocketMQ

  - ActiveMQ：http://activemq.apache.org/

    - Apache出品，历史悠久，支持多种语言的客户端和协议，支持多种语言Java, .NET, C++ 等，基于JMS Provider的实现

    缺点：吞吐量不高，多队列的时候性能下降，存在消息丢失的情况，比较少大规模使用

  - Kafka：http://kafka.apache.org/

    - 是由Apache软件基金会开发的一个开源流处理平台，由Scala和Java编写。Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理大规模的网站中的所有动作流数据(网页浏览，搜索和其他用户的行动)，副本集机制，实现数据冗余，保障数据尽量不丢失；支持多个生产者和消费者

    缺点：不支持批量和广播消息，运维难度大，文档比较少, 需要掌握Scala

  - RabbitMQ：http://www.rabbitmq.com/

    - 是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不错

    缺点：使用Erlang开发，阅读和修改源码难度大

  - RocketMQ：http://rocketmq.apache.org/

    - 阿里开源的一款的消息中间件, 纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点, 性能强劲(零拷贝技术)，支持海量堆积, 支持指定次数和时间间隔的失败消息重发,支持consumer端tag过滤、延迟消息等，在阿里内部进行大规模使用，适合在电商，互联网金融等领域使用
    - 缺点：成熟的资料相对不多，社区处于新生状态但是热度高

 

 

 

 

 

#### 第2集 你知道 oneway/延迟消息的使用场景吗

**简介：是否知道oneway、延迟消息等类型消息的应用**

- 考点：是否有了解主流消息队列oneway、延迟消息的使用
- 难度：【 ** **】
- 消息队列的发送方式有哪几种，使用场景分别是怎样的？

```
发送方式一般分三种

SYNC 同步发送
应用场景：重要通知邮件、报名短信通知、营销短信系统等

ASYNC 异步发送
应用场景：对RT时间敏感,可以支持更高的并发，回调成功触发相对应的业务，比如注册成功后通知积分系统发放优惠券

ONEWAY 无需要等待响应
应用场景：主要是日志收集，适用于某些耗时非常短，但对可靠性要求并不高的场景, 也就是LogServer, 只负责发送消息，不等待服务器回应且没有回调函数触发，即只发送请求 不等待应答
```

发送方式汇总对比

| 发送方式 | 发送 TPS | 发送结果反馈 | 可靠性   |
| :------- | :------- | :----------- | :------- |
| 同步发送 | 快       | 有           | 不丢失   |
| 异步发送 | 快       | 有           | 不丢失   |
| 单向发送 | 最快     | 无           | 可能丢失 |



- 有没用过延迟消息，使用场景是怎样的？

```
什么是延迟消息：
	Producer 将消息发送到消息队列 broker服务端，但并不期望这条消息立马投递，而是推迟到在当前时间点之后的某一个时间投递到 Consumer 进行消费

使用场景一：通过消息触发一些定时任务，比如在某一固定时间点向用户发送提醒消息
使用场景二：消息生产和消费有时间窗口要求，比如在天猫电商交易中超时未支付关闭订单的场景，在订单创建时会发送一条 延时消息。这条消息将会在 30 分钟以后投递给消费者，消费者收到此消息后需要判断对应的订单是否已完成支付。 如支付未完成，则关闭订单。如已完成支付则忽略
```

![image-20200225121843174](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC9%E7%AB%A0/%E7%AC%AC2%E9%9B%86/image-20200225121843174.png)

 

 

 

 

 

 

 

#### 第3集 如何保证消息队列里消息的生成和消费的顺序性

**简介：是否知道如何保证消息队列的消息生成和消费的顺序性**

- 考点：如何保证消息队列的消息生成和消费的顺序性
- 难度：【 ** ** *】
- 你用的队列是否支持顺序消息，是怎么实现顺序消息的？

```
什么是顺序消息：
	消息的生产和消费顺序一致
	
	全局顺序：topic下面全部消息都要有序(少用)，性能要求不高，所有的消息严格按照 FIFO 原则进行消息发布和消费的	场景，并行度成为消息系统的瓶颈, 吞吐量不够
	使用场景：在证券处理中，以人民币兑换美元为例子，在价格相同的情况下，先出价者优先处理，则可以通过全局顺序的方式按照 FIFO 的方式进行发布和消费
	
	局部顺序：只要保证一组消息被顺序消费即可，性能要求高
	使用场景：电商的订单创建，同一个订单相关的创建订单消息、订单支付消息、订单退款消息、订单物流消息、订单交易成功消息 都会按照先后顺序来发布和消费
	（阿里巴巴集团内部电商系统均使用局部顺序消息，既保证业务的顺序，同时又能保证业务的高性能）


下面是用RocketMQ举例(用kafka或rabbitmq类似)
一个topic下面有多个queue

顺序发布：对于指定的一个 Topic，客户端将按照一定的先后顺序发送消息
举例：订单的顺序流程是：创建、付款、物流、完成，订单号相同的消息会被先后发送到同一个队列中，
根据MessageQueueSelector里面自定义策略，根据同个业务id放置到同个queue里面，如订单号取模运算再放到selector中，同一个模的值都会投递到同一条queue
   
   public MessageQueue select(List<MessageQueue> mqs, Message msg, Object arg) {
            //如果是订单号是字符串，则进行hash,得到一个hash值
          Long id = (Long) arg;
          long index = id % mqs.size();
          return mqs.get((int)index);
   }


顺序消费：对于指定的一个 Topic，按照一定的先后顺序接收消息，即先发送的消息一定会先被客户端接收到。
举例：消费端要在保证消费同个topic里的同个队列，不应该用MessageListenerConcurrently，
  应该使用MessageListenerOrderly，自带单线程消费消息，不能再Consumer端再使用多线程去消费，消费端分配到的queue数量是固定的，集群消费会锁住当前正在消费的队列集合的消息，所以会保证顺序消费。

注意：
   顺序消息暂不支持广播模式
   顺序消息不支持异步发送方式，否则将无法严格保证顺序
   不能再Consumer端再使用多线程去消费
```

![image-20200225121812567](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC9%E7%AB%A0/%E7%AC%AC3%E9%9B%86/image-20200225121812567.png)

 

 

 

 

#### 第4集 消息队列常见问题之怎么避免重复消费

**简介：考查怎么样可以避免重复消费**

- 考点：是否有真正用过消息队列，是否设计过重复消费

- 难度：【 ** ** *】

- 你的业务系统有没做消息的重复消费处理，是怎么做的

  - 幂等性：一个请求，不管重复来多少次，结果是不会改变的。

  - RabbitMQ、RocketMQ、Kafka等任何队列不保证消息不重复，如果业务需要消息不重复消费，则需要消费端处理业务消息要保持幂等性

    - 方式一：Redis的setNX() , 做消息id去重 java版本目前不支持设置过期时间

    ```
    //Redis中操作，判断是否已经操作过 TODO
    boolean flag =  jedis.setNX(key);
    if(flag){
            //消费
    }else{
            //忽略，重复消费
    }
    ```

     

    - 方式二：redis的 Incr 原子操作：key自增，大于0 返回值大于0则说明消费过，(key可以是消息的md5取值, 或者如果消息id设计合理直接用id做key)

    ```
    int num =  jedis.incr(key);
    if(num == 1){
    	//消费
    }else{
    	//忽略，重复消费
    }
    ```

    

    - 方式三：数据库去重表

      - 设计一个去重表，某个字段使用Message的key做唯一索引，因为存在唯一索引，所以重复消费会失败

        CREATE TABLE `message_record` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `key` varchar(128) DEFAULT NULL, `create_time` datetime DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `key` (`key`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

  ![image-20200225121742209](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC9%E7%AB%A0/%E7%AC%AC4%E9%9B%86/image-20200225121742209.png)

 

 

 

 

#### 第5集 消息队列常见问题之如何保证消费的可靠性传输？

**简介：如何保证消费的可靠性传输**

- 考点：是否有研究消息队列的底层原理，保证消息的可靠性传输，消息队列的架构

- 难度：【 ** *** 】

- 你用了消息队列，你知道这个消息队列如何保证消息的可靠性传输吗

  ```
  消息可靠性传输，是非常重要，消息如果丢失，可能带来严重后果，一般从是个角度去分析
  producer端：
  	不采用oneway发送，使用同步或者异步方式发送，做好重试，但是重试的Message key必须唯一
  	投递的日志需要保存，关键字段，投递时间、投递状态、重试次数、请求体、响应体
  
  broker端：
  	多主多从架构，需要多机房
  	同步双写、异步刷盘 (同步刷盘则可靠性更高，但是性能差点，根据业务选择)
  	机器断电重启：异步刷盘，消息丢失；同步刷盘消息不丢失
  	硬件故障：可能存在丢失，看队列架构
  	
  consumer端
  	消息队列一般都提供的ack机制，发送者为了保证消息肯定消费成功，只有消费者明确表示消费成功，队列才会认为消息消费成功，中途断电、抛出异常等都不会认为成功——即都会重新投递，每次在确保处理完这个消息之后，在代码里调用ack，告诉消息队列消费成功
  消费端务必做好幂等性处理
  消息消费务必保留日志，即消息的元数据和消息体，
  ```

![image-20200225121709073](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC9%E7%AB%A0/%E7%AC%AC5%E9%9B%86/image-20200225121709073.png)

 

 

 

 

 

 

 

 

#### 第6集 消息队列常见问题之消息发生大量堆积应该怎么处理？

**简介：如果消息大量堆积在broker里面，应该怎么处理**

- 考点：是否有研究消息队列不可用后的应急方案，是否有架构思维
- 难度：【 ** *** 】
- 线上故障了，怎么处理
  - 消息堆积了10小时，有几千万条消息待处理，现在怎么办?
  - 修复consumer, 然后慢慢消费？也需要几小时才可以消费完成，新的消息怎么办？

 

```
核心思想：紧急临时扩容，更快的速度去消费数据

- 修复Consumer不消费问题，使其恢复正常消费，根据业务需要看是否要暂停

- 临时topic队列扩容，并提高消费者能力，但是如果增加Consumer数量，但是堆积的topic里面的message queue数量固定，过多的consumer不能分配到message queue


- 编写临时处理分发程序，从旧topic快速读取到临时新topic中，新topic的queue数量扩容多倍，然后再启动更多consumer进行在临时新的topic里消费

- 直到堆积的消息处理完成，再还原到正常的机器数量
```

![image-20200225121517029](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC9%E7%AB%A0/%E7%AC%AC6%E9%9B%86/image-20200225121517029.png)

 

![image-20200225121605489](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC9%E7%AB%A0/%E7%AC%AC6%E9%9B%86/image-20200225121605489.png)

 

![image-20200225121630567](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC9%E7%AB%A0/%E7%AC%AC6%E9%9B%86/image-20200225121630567.png)

**![logo](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/image/logo.png) 愿景："让编程不再难学，让技术与生活更加有趣"**

**更多高级架构课程请访问 xdclass.net**

### 第十章 MySQL数据库的面试题你遇过多少



#### 第1集 常说的事务ACID是什么

**简介：是否掌握事务的ACID原理**

- 考点：是否掌握事务的ACID原理
- 难度：【 **】
- 你知道Mysql事务的四大特性不，简单说下

```
事务的四大特性ACID
原子性Atomicity：
  一个事务必须被事务不可分割的最小工作单元，整个操作要么全部成功，要么全部失败，一般就是通过commit和rollback来控制
  
一致性Consistency:
  数据库总能从一个一致性的状态转换到另一个一致性的状态，比如小滴课堂下单支付成功后，开通视频播放权限，只要有任何一方发生异常就不会成功提交事务
  
隔离性Isolation:
  一个事务相对于另一个事务是隔离的，一个事务所做的修改是在最终提交以前，对其他事务是不可见的
  
持久性Durability:
  一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失
```

 

 

 

 

 

 

 

 

#### 第2集 脏读-不可重复读-幻读你知道多少

**简介：考查数据库隔离级别导致的问题**

- 考点：是否掌握数据库常见隔离级别和对应导致的问题
- 难度：【 ** **】
- 能否简单解释下脏读、不可重复读、幻读的意思

```
脏读: 事务中的修改即使没有提交，其他事务也能看见，事务可以读到未提交的数据称为脏读

不可重复读: 同个事务前后多次读取，不能读到相同的数据内容，中间另一个事务也操作了该同一数据

幻读：当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，发现两次不一样，产生幻读


幻读和不可重复读的区别是：前者是一个范围，后者是本身，从总的结果来看, 两者都表现为两次读取的结果不一致
```

 

- 常见的隔离级别由低到高有哪几种，mysql默认是哪种

```
事务的隔离级别越高，事务越安全，但是并发能力越差。

Read Uncommitted(未提交读，读取未提交内容)
  事务中的修改即使没有提交，其他事务也能看见，事务可以读到为提交的数据称为脏读
  也存在不可重复读、幻读问题

例子：
  小滴课堂运营小姐姐配置了一个课程活动，原价500元的课程，配置成50元，但是事务没提交。 
  你刚好看到这个课程那么便宜准备购买，但是Anna小姐姐马上回滚了事务，重新配置并提交了事务，你准备下单的时候发现价格变回了500元



Read Committed(提交读，读取提交内容)
  一个事务开始后只能看见已经提交的事务所做的修改，在事务中执行两次同样的查询可能得到不一样的结果，也叫做不可重复读(前后多次读取，不能读到相同的数据内容)，也存幻读问题
  
例子：
  老王在小滴课堂有1000积分，准备去兑换《面试专题课程》，查询数据库确实有1000积分
  但是老王的女友同时也在别的地方登录，把1000积分兑换了《SpringCloud微服务专题课程》，且在老王之前提交事务；当系统帮老王兑换《面试专题课程》是发现积分预计没了，兑换失败。
  
  老王事务A事先读取了数据，他女友事务B紧接了更新了数据且提交了事务，事务A再次读取该数据时，数据已经发生了改变
  
  
  
Repeatable Read(可重复读,mysql默认的事务隔离级别)
  解决脏读、不可重复读的问题，存在幻读的问题，使用 MMVC机制 实现可重复读
  
  例子
  老王在小滴课堂有1000积分，准备去兑换《面试专题课程》，查询数据库确实有1000积分
  老王的女友同时也在别的地方登录先兑换了这个《面试专题课程》，老王的事务提交的时候发现存在了，之前读取的没用了，像是幻觉

  幻读问题：MySQL的InnoDB引擎通过MVCC自动帮我们解决,即多版本并发控制

Serializable(可串行化)
  解决脏读、不可重复读、幻读，可保证事务安全，但强制所有事务串行执行，所以并发效率低
```

 

 

 

#### 第3集 Mysql常见的存储引擎你知道不

**简介：考查mysql的存储引擎**

- 考点：是否知道Mysql的存储引擎

- 难度：【 **】

- 说下你知道Mysql常见的存储引擎，新版Mysql默认是哪个

  ```
  常见的有多类，InnoDB、MyISAM、MEMORY、MERGE、ARCHIVE、CSV等
  一般比较常用的有InnoDB、MyISAM
  MySQL 5.5以上的版本默认是InnoDB，5.5之前默认存储引擎是MyISAM
  ```

   

 

 

 

 

 

 

 

 

 

 

#### 第4集 存储引擎InnoDB、MyISAM异同点和选择

**简介：考查mysql的存储引擎InnoDB&MyISAM的异同和选择**

- 考点：是否了解Mysql的存储引擎InnoDB&MyISAM区别和选择问题
- 难度：【 ** **】
- mysql的存储引擎 innodb和myisam有什么区别，应该怎么选择

|  区别项  |                     Innodb                      |          myisam          |
| :------: | :---------------------------------------------: | :----------------------: |
|   事务   |                      支持                       |          不支持          |
|  锁粒度  |                行锁，适合高并发                 |    表锁，不适合高并发    |
| 是否默认 |                      默认                       |          非默认          |
| 支持外键 |                    支持外键                     |          不支持          |
| 适合场景 |         读写均衡,写大于读场景，需要事务         | 读多写少场景，不需要事务 |
| 全文索引 | 不支持，可以通过插件实现, 更多使用ElasticSearch |       支持全文索引       |

 

 



 

 

 

#### 第5集 Mysql数据库索引你知道多少

**简介：考查mysql的功能索引掌握情况**

- 考点：mysql的功能索引
- 难度：【 ** **】
- mysql常用的功能索引有哪些
- 分别在什么场景下使用
- 创建语句是怎样的

| 索引名称 |                             特点                             |      | 创建语句                                                     |
| :------: | :----------------------------------------------------------: | :--: | :----------------------------------------------------------- |
| 普通索引 |                   最基本的索引,仅加速查询                    |      | CREATE INDEX idx_name ON table_name(filed_name)              |
| 唯一索引 | 加速查询，列值唯一，允许为空； 组合索引则列值的组合必须唯一  |      | CREATE UNIQUE INDEX idx_name ON table_name(filed_name_1,filed_name_2) |
| 主键索引 |       加速查询，列值唯一， 一个表只有1个，不允许有空值       |      | ALTER TABLE table_name ADD PRIMARY KEY ( filed_name )        |
| 组合索引 |                   加速查询，多条件组合查询                   |      | CREATE INDEX idx_name ON table_name(filed_name_1,filed_name_2); |
| 覆盖索引 | 索引包含所需要的值，不需要“回表”查询， 比如查询 两个字段，刚好是 组合索引 的两个字段 |      |                                                              |
| 全文索引 | 对内容进行分词搜索，仅可用于Myisam， 更多用ElasticSearch做搜索 |      | ALTER TABLE table_name ADD FULLTEXT ( filed_name )           |

 

 

 

 

 

 

 

 

 

 

#### 第6集 数据库索引的好处和坏处,你常用的最佳实践

**简介：讲解索引的使用场景和注意事项**

- 考点：考查索引的使用场景和注意事项
- 难度：【 ** **】
- 你们线上数据量每天有多少新增，都是存储在mysql库吗，有没做优化

```
中型公司或者业务发展好的公司，一天新增几百万数据量

业务核心数据存储在Mysql里面，针对业务创建合适的索引

打点数据、日志等存储在ElasticSearch或者MongoDB里面
```

 

- 你创建索引的时候主要考虑啥，使用索引的优缺点有哪些，使用应该注意些什么

```
考虑点：结合实际的业务场景，在哪些字段上创建索引，创建什么类型的索引

索引好处：
  快速定位到表的位置，减少服务器扫描的数据
  有些索引存储了实际的值，特定情况下只要使用索引就能完成查询

索引缺点：
  索引会浪费磁盘空间，不要创建非必要的索引
  插入、更新、删除需要维护索引，带来额外的开销
  索引过多，修改表的时候重构索引性能差

索引优化实践
  前缀索引，特别是TEXT和BLOG类型的字段，只检索前面几个字符，提高检索速度
  尽量使用数据量少的索引，索引值过长查询速度会受到影响
  选择合适的索引列顺序
  内容变动少，且查询频繁，可以建立多几个索引
  内容变动频繁，谨慎创建索引
  根据业务创建适合的索引类型，比如某个字段常用来做查询条件，则为这个字段建立索引提高查询速度
  组合索引选择业务查询最相关的字段
```

 

 

 

 

**![logo](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/image/logo.png) 愿景："让编程不再难学，让技术与生活更加有趣"**

**更多高级架构课程请访问 xdclass.net**

### 第十一章 数据库设计查询和上线里面的坑你走过多少

 

#### 第1集 数据库查询关键词执行顺序

**简介：数据库查询指令的执行顺序**

- 考点：考查数据库查询指令的执行顺
- 难度：【 ** *】
- 数据库查询的指令有多个，说下执行顺序 select、where、from、group by、having、order by

```
from 从哪个表查询
where 初步过滤条件
group by 过滤后进行分组[重点]
having 对分组后的数据进行二次过滤[重点]
select 查看哪些结果字段
order by 按照怎样的顺序进行排序返回[重点]


select video_id,count(id) num from chapter group by video_id  having num >10
order by video_id desc
```

- 建议：去网上找sql练习题

 

 

 

 

 

 

 

 

 

 

#### 第2集 设计数据库表时相似字段类型你能区分吗《上》

**简介：设计数据库的时候相似类型的字段区分**

- 考点：是否知道常用的相似字段他们的区别
- 难度：【 ** *】
- varchar(len) char(len) len存储的是字符还是字节
- MySQL中的varchar和char有什么区别，应该怎么选择

|    对比项    |                     char(16)                      |                  varchar(16)                   |
| :----------: | :-----------------------------------------------: | :--------------------------------------------: |
|   长度特点   |                长度固定，存储字符                 |               长度可变，存储字符               |
| 长度不足情况 |      插入的长度小于定义长度时，则用空格填充       |       小于定义长度时，按实际插入长度存储       |
|     性能     |              存取速度比varchar快得多              |              存取速度比char慢得多              |
|   使用场景   | 适合存储很短的,固定长度的字符串,如手机号，MD5值等 | 适合用在长度不固定场景，如收货地址，邮箱地址等 |
|              |                                                   |                                                |

 

 

 

 

 

 

 

 

#### 第3集 2038年1月19号会有多少系统产生bug，相似字段类型区分《下》

**简介：设计数据库的时候相似类型的字段区分**

- 考点：是否知道常用的数据库时间类型相似字段的区别
- 难度：【 ** **】
- MySQL中的datetime和timestamp有什么区别

| 类型      | 占据字节 | 范围                                       | 时区问题                                     |      |
| :-------- | :------- | :----------------------------------------- | :------------------------------------------- | :--- |
| datetime  | 8 字节   | 1000-01-01 00:00:00到 9999-12-31 23:59:59  | 存储与时区无关，不会发生改变                 |      |
| timestamp | 4 字节   | 1970-01-01 00:00:01 到 2038-01-19 11:14:07 | 存储的是与时区有关，随数据库的时区而发生改变 |      |

- 为什么timestamp只能到2038年

```
MySQL的timestamp类型是4个字节，最大值是2的31次方减1，结果是2147483647，
转换成北京时间就是2038-01-19 11:14:07
```

 

 

 

 

 

#### 第4集 场景模拟之千万级Mysql数据表分页查询优化

**简介：针对大数据量sql分页优化思路**

- 考点：是否有大数据分页优化思路
- 难度：【 ** **】
- 线上数据库的一个商品表数据量过千万，做深度分页的时候性能很慢，有什么优化思路

```
现象：千万级别数据很正常，比如数据流水、日志记录等，数据库正常的深度分页会很慢
慢的原因：select * from product limit N,M
MySQL执行此类SQL时需要先扫描到N行，然后再去取M行,N越大,MySQL扫描的记录数越多，SQL的性能就会越差

1、后端、前端缓存

2、使用ElasticSearch分页搜索

3、合理使用 mysql 查询缓存，覆盖索引进行查询分页
  select title,cateory from product limit 1000000,100
  
4、如果id是自增且不存在中间删除数据，使用子查询优化，定位偏移位置的 id
select * from oper_log where type='BUY' limit 1000000,100; //5.秒
      
select id from oper_log where type='BUY' limit 1000000,1; // 0.4秒 

select * from oper_log where type='BUY' and  id>=(select id from oper_log where type='BUY' limit 1000000,1) limit 100; //0.8秒 
```

 

 

 

 

 

 

 

 

#### 第5集 BAT大厂里面 应用版本更新，数据库上线流程

**简介：掌握大厂里面数据库上线流程，版本更新流程**

- 考点：是否有正确的数据库部署流程
- 难度：【 ** ***】
- 你公司里面产品迭代更新，开发好代码和数据库，上线流程是怎样的

![image-20200229195411491](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC11%E7%AB%A0/%E7%AC%AC5%E9%9B%86/image-20200229195411491.png)

 

 

 

**![logo](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/image/logo.png) 愿景："让编程不再难学，让技术与生活更加有趣"**

**更多高级架构课程请访问 xdclass.net**

### 第十二章 生产环境数据库性能监控和优化面试环节

#### 第1集 生产环境的数据库，你会做哪些操作保证安全

**简介：生成环境监控指标和安全**

- 考点：是否有监控和数据安全思维
- 难度：【 ** ***】
- 针对线上的数据库，你会做哪些监控，业务性能 + 数据安全 角度分析

```
大厂一般都有数据库监控后台，里面指标很多，但是开发人员也必须知道

业务性能
    1、应用上线前会审查业务新增的sql，和分析sql执行计划
        比如是否存在 select * ，索引建立是否合理
    2、开启慢查询日志，定期分析慢查询日志

    3、监控CPU/内存利用率，读写、网关IO、流量带宽 随着时间的变化统计图
    
    4、吞吐量QPS/TPS，一天内读写随着时间的变化统计图

数据安全
    1、短期增量备份，比如一周一次。 定期全量备份，比如一月一次

    2、检查是否有非授权用户，是否存在弱口令，网络防火墙检查

    3、导出数据是否进行脱敏，防止数据泄露或者黑产利用

    4、数据库 全量操作日志审计，防止数据泄露
    
    5、数据库账号密码 业务独立，权限独立控制，防止多库共用同个账号密码
    
    6、高可用 主从架构，多机房部署
```

 

 

 

#### 第2集 你知道Mysql里面有多少种日志

**简介：mysql常见日志的考查**

- 考点：mysql常见日志种类和作用

- 难度：【 ** ** 】

- Mysql有多少种常见的日志，分别解释日志的作用

  ```
  redo 重做日志
    作用：确保事务的持久性，防止在发生故障，脏页未写入磁盘。重启数据库会进行redo log执行重做，到达事务一致性
    
  undo 回滚日志
    作用：保证数据的原子性，记录事务发生之前的数据的一个版本，用于回滚。
    innodb事务的可重复读和读取已提交 隔离级别就是通过mvcc+undo实现
    
  errorlog 错误日志
    作用：Mysql本身启动、停止、运行期间发生的错误信息
    
  slow query log 慢查询日志
    作用：记录执行时间过长的sql，时间阈值可以配置，只记录执行成功
  
  binlog 二进制日志
    作用：用于主从复制，实现主从同步
    
  relay log 中继日志
    作用：用于数据库主从同步，将主库发送来的binlog先保存在本地，然后从库进行回放
    
  general log 普通日志
    作用：记录数据库操作明细，默认关闭，开启会降低数据库性能
  ```

   

 

 

#### 第3集 层层套路之数据库主从复制里面知识考查

**简介：数据库主从的用途、原理流程**

- 考点：是否搭建过主从，并掌握原理
- 难度：【 ** ***】
- 你们数据库是单点的吗？有没做多节点优化 ，怎么做的

```
我们公司数据库不是单节点，是多节点的，有做主从复制
```

- 既然搭建过数据库主从复制，你能画下流程图说下异步复制原理不

![image-20200229195643201](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC12%E7%AB%A0/%E7%AC%AC3%E9%9B%86/image-20200229195643201.png)

 

 

 

 

 

 

 

 

#### 第4集 层层套路之数据库主从同步遇到的问题

**简介：数据库主从遇到的问题和解决办法**

- 考点：搭建过主从，肯定有遇过些问题，解决思路
- 难度：【 ** ** *】
- 你们搭建数据库主从复制的目的有哪些

```
容灾使用，用于故障切换
业务需要，进行读写分离减少主库压力
```

- 既然你们搭建了主从同步，且你们日增量数据量也不少，有没遇到同步延迟问题
- 为什么会有同步延迟问题，怎么解决？

```
保证性能第一情况下，不能百分百解决主从同步延迟问题，只能增加缓解措施。

现象：主从同步，大数据量场景下，会发现写入主库的数据，在从库没找到。

原因：
  1、主从复制是单线程操作，当主库TPS高，产生的超过从库sql线程执行能力

  2、从库执行了大的sql操作，阻塞等待
  
  3、服务器硬件问题，如磁盘，CPU,还有网络延迟等
  
解决办法：
  1、业务需要有一定的容忍度，程序和数据库直接增加缓存，降低读压力

  2、业务适合的话，写入主库后，再写缓存，读的时候可以读缓存，没命中再读从库

  3、读写分离，一主多从，分散主库和从库压力
  
  4、提高硬件配置，比如使用SSD固态硬盘、更好的CPU和网络
  
  5、进行分库分表，减少单机压力
  
```

![image-20200229195817665](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC12%E7%AB%A0/%E7%AC%AC4%E9%9B%86/image-20200229195817665.png)

 

 

 

 

#### 第5集 Mysql主从复制数据一致性校验方案怎么做

**简介：数据库主从复制数据一致性校验方案**

- 考点：搭建主从复制，有没做过数据一致性校验
- 难度：【 ** ** *】
- 什么场景下会出现主从数据不一致

```
1、本身复制延迟导致
2、主库宕机或者从库宕机都会导致复制中断
3、把一个从库提升为主库，可能导致从库和主库的数据不一致性
```

- 是否有做过主从一致性校验，你是怎么做的，如果没做过，你计划怎么做
- 如果不一致你会怎么修复

```
Mysql主从复制是基于binlog复制，难免出现复制数据不一致的风险，引起用户数据访问前后不一致的风险
所以要定期开展主从复制数据一致性的校验并修复，避免这些问题

解决方案之一，使用Percona公司下的工具

pt-table-checksum工具进行一致性校验

  原理：
  主库利用表中的索引，将表的数据切割成一个个chunk(块)，然后进行计算得到checksum值。
  从库也执相应的操作，并在从库上计算相同数据块的checksum，然后对比主从中各个表的checksum是否一致并存储到数据库，最后通过存储校验结果的表就可以判断出哪些表的数据不一致


pt-table-sync(在从库执行)工具进行修复不一致数据，可以修复主从结构数据的不一致，也可以修复非主从结构数据表的数据不一致

  原理：在主库上执行数据的更改，再同步到从库上，不会直接更改成从的数据。在主库上执行更改是基于主库现在的数据，也不会更改主库上的数据，可以同步某些表或整个库的数据，但它不同步表结构、索引，只同步不一致的数据


注意：
  默认主库要检查的表在从库都存在，并且同主库表有相同的表结构
  如果表中没有索引，pt-table-checksum将没法处理，一般要求最基本都要有主键索引
  pt-table-sync工具会修改数据，使用前最好备份下数据，防止误操作
```

- pt-table-checksum怎么保证某个chunk的时候checksum数据一致性？

```
当pt工具在计算主库上某chunk的checksum时，主库可能在更新且从库可能复制延迟，那该怎么保证主库与从库计算的是”同一份”数据，答案把要checksum的行加上for update锁并计算，这保证了主库的某个chunk内部数据的一致性
```

 

官方地址：https://www.percona.com/downloads/percona-toolkit/LATEST/

其他资料：https://www.cnblogs.com/zishengY/p/6852280.html

 

 

 

 

 

 

 

 

**![logo](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/image/logo.png) 愿景："让编程不再难学，让技术与生活更加有趣"**

### 【简历编写章】 带你看小滴课堂微服务架构+编写面试BAT高级工程师简历

 

#### 第1集 你知道未来的小滴课堂微服务架构图吗？

**简介：概述分析小滴课堂未来架构图，作为简历编写铺垫**

- 小滴课堂未来架构拆分
- 微服务下的系统模块功能概述

![image-20200303233428197](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC1%E7%AB%A0/%E7%AC%AC1%E9%9B%86/image-20200303233428197.png)

 

 

 

#### 第2集 你知道怎么编写一份合格的初级+高级工程师简历吗

**简介：简历常见的模块，哪些应该写，哪些不应该写**

- 个人信息
- 教育经历
- 技术栈
- 工作经历
- 个人评价

 

 

 

 

 

 

 

#### 第3集 编写面试大厂月薪20k+的高级工程师简历【原创】

**简介：讲师小D原创，解读一份面试大厂高级工程师的简历**

- 个人信息
- 教育经历
- 技术栈
- 工作经历
- 个人评价

![image-20200303195610120](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC1%E7%AB%A0/%E7%AC%AC1%E9%9B%86/image-20200303195610120.png)

 

 

 

 

#### 第4集 简历项目经验讲解之在线教育视频服务

**简介：讲解简历里面的项目经验-视频服务**

![image-20200303195720672](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC1%E7%AB%A0/%E7%AC%AC1%E9%9B%86/image-20200303195720672.png)

 

![image-20200303233529453](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC1%E7%AB%A0/%E7%AC%AC1%E9%9B%86/image-20200303233529453.png)

 

 

 

 

 

 

 

 

#### 第5集 简历项目经验之电商核心支付网关

**简介：概述简历里面的支付网关知识**

![image-20200303195742539](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC1%E7%AB%A0/%E7%AC%AC1%E9%9B%86/image-20200303195742539.png)

![image-20200303233459841](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC1%E7%AB%A0/%E7%AC%AC1%E9%9B%86/image-20200303233459841.png)

 

 

 

 

 

 

 

 

 

#### 第6集 简历项目经验之用户中心的作用

**简介：概述简历里面的用户中心的作用**

![image-20200303195759000](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC1%E7%AB%A0/%E7%AC%AC1%E9%9B%86/image-20200303195759000.png)

 

 

 

 

 

 

 

 

#### 第7集 简历项目经验之营销插件服务

**简介：概述简历里面的营销插件服务**

![image-20200303200124649](https://file.xdclass.net/note/2020/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/%E7%AC%AC1%E7%AB%A0/%E7%AC%AC1%E9%9B%86/image-20200303200124649.png)

 

 

 

 

 

 

 

 

#### 第8集 简历编写总结回顾，酒香不怕巷子深

**简介：总结回顾简历编写的实现**

 

 

 

 

 



 